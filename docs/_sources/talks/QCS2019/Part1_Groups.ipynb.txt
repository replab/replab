{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 1. Constructing groups with RepLAB\n",
    "\n",
    "We demonstrate a few ways to construct groups using RepLAB. This notebook is a companion to the RepLAB talk at the [Quantum Causal Structures](http://www.cs.ox.ac.uk/conferences/QCS2019/) workshop."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We start by adding RepLAB to the path. The output below has been generated using MATLAB, but RepLAB is also compatible with recent versions of Octave (>= 4.2)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Adding RepLAB to the path\r\n",
      "warning: function /home/denis/Projects/replab/src/help.m shadows a core library function\r\n",
      "Adding RepLAB package to the path\r\n",
      "Adding VPI to the path\r\n",
      "Adding MOxUnit to the path\r\n",
      "Adding embedded YALMIP to the path\r\n",
      "Adding embedded SDPT3 solver to the path\r\n",
      "Adding MOcov to the path\r\n"
     ]
    }
   ],
   "source": [
    "run ../../../replab_init.m"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Group axioms / laws\n",
    "RepLAB has knowledge of the group axioms, and can verify them using random sampling of elements. By default, 20 instances are checked for every law. Inspired by [QuickCheck](https://en.wikipedia.org/wiki/QuickCheck)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Checking associativity...\r\n",
      "Checking composeAll...\r\n",
      "Checking composeN integers...\r\n",
      "Checking composeN positive...\r\n",
      "Checking composeN zero...\r\n",
      "Checking eqv...\r\n",
      "Checking identity...\r\n",
      "Checking inverse...\r\n",
      "Checking inverse compatible with compose...\r\n"
     ]
    }
   ],
   "source": [
    "S4 = replab.S(4);\n",
    "replab.GroupLaws(S4).check"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Permutation groups\n",
    "RepLAB uses row vectors of 1-based integers as group elements, which facilitates integration with existing MATLAB code. When constructing a permutation group `replab.S(n)`, we construct an instance of `replab.FiniteGroup` that knows how to interpret those integer row vectors as permutations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sigma =\r\n",
      "\r\n",
      "   1   4   3   2\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "S4 = replab.S(4); % or replab.Permutations(4)\n",
    "pi = [3 4 1 2]; rho = [3 2 1 4];\n",
    "sigma = S4.compose(pi, rho)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "  1  1  1  1\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "pi(rho([1 2 3 4])) == sigma([1 2 3 4])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Permutation subgroups\n",
    "We can also construct subgroups of S(n) using a list of generators. Example for conditional probability distributions for two measurements settings with two outcomes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "error: can't perform indexing operations for user-defined function type\r\n"
     ]
    }
   ],
   "source": [
    "piInput = [3 4 1 2];\n",
    "piOutput1 = [2 1 3 4];\n",
    "piOutput2 = [1 2 4 3];\n",
    "GAlice = replab.S(4).subgroup({piInput piOutput1 piOutput2})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "error: 'GAlice' undefined near line 1 column 1\r\n"
     ]
    }
   ],
   "source": [
    "GAlice.order"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "error: 'GAlice' undefined near line 1 column 1\r\n"
     ]
    }
   ],
   "source": [
    "GAlice.elements"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "error: can't perform indexing operations for user-defined function type\r\n",
      "error: 'GAlice1' undefined near line 1 column 1\r\n"
     ]
    }
   ],
   "source": [
    "GAlice1 = replab.S(4).subgroup({piInput piOutput1}); % test removing the last generator\n",
    "GAlice1.order"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Signed permutations\n",
    "Signed permutation groups are also supported with similar syntax."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "error: member `SignedPermutations' in package `replab' does not exist\r\n"
     ]
    }
   ],
   "source": [
    "sParties = [3 4 1 2];\n",
    "sFlip = [-1 -2 -3 -4];\n",
    "sOther = [2 1 3 -4];\n",
    "GCHSH = replab.SignedPermutations(4).subgroup({sParties sFlip sOther})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "error: 'GCHSH' undefined near line 1 column 1\r\n"
     ]
    }
   ],
   "source": [
    "GCHSH.order"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "error: 'GCHSH' undefined near line 1 column 1\r\n"
     ]
    }
   ],
   "source": [
    "GCHSH.elements"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Wreath product groups\n",
    "We construct the wreath product of S(2) on S(2), representing the symetries of \"two measurement settings with two outcomes\"."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "error: member `WreathProductGroup' in package `replab' does not exist\r\n"
     ]
    }
   ],
   "source": [
    "Goutcomes = replab.S(2);\n",
    "Gsettings = replab.S(2);\n",
    "Gparty = replab.WreathProductGroup(Gsettings, Goutcomes)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "error: 'Gparty' undefined near line 1 column 1\r\n"
     ]
    }
   ],
   "source": [
    "Gparty.elements"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Octave",
   "language": "octave",
   "name": "octave"
  },
  "language_info": {
   "file_extension": ".m",
   "help_links": [
    {
     "text": "GNU Octave",
     "url": "https://www.gnu.org/software/octave/support.html"
    },
    {
     "text": "Octave Kernel",
     "url": "https://github.com/Calysto/octave_kernel"
    },
    {
     "text": "MetaKernel Magics",
     "url": "https://metakernel.readthedocs.io/en/latest/source/README.html"
    }
   ],
   "mimetype": "text/x-octave",
   "name": "octave",
   "version": "4.4.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
