{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Relabelings in the CHSH scenario\n",
    "\n",
    "We describe the output/input/party relabelings in the CHSH scenario, and decompose their action on probability distributions $P(ab|xy)$.\n",
    "\n",
    "We identify those relabelings with a [wreath product](https://en.wikipedia.org/wiki/Wreath_product) construction, which RepLAB supports. This topic guide can be considered as a (small) introduction to the group constructions available in RepLAB."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Before using *RepLAB* commands, we must first initialize the library:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Adding RepLAB to the path\r\n",
      "warning: function /home/denis/w/replab/src/help.m shadows a core library function\r\n",
      "Adding RepLAB package to the path\r\n",
      "Adding VPI to the path\r\n",
      "Adding MOxUnit to the path\r\n",
      "Adding embedded YALMIP to the path\r\n",
      "Adding embedded SDPT3 solver to the path\r\n",
      "Adding MOcov to the path\r\n"
     ]
    }
   ],
   "source": [
    "run ../../replab_init"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Relabelings the outputs\n",
    "\n",
    "Outputs are binary, so the relabelling of outputs is the symmetric group\n",
    "of domain size 2. The representation of this relabelling on the\n",
    "probabilities $P(a)$ is then the defining representation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "outputGroup =\r\n",
      "\r\n",
      "Permutations acting on 2 elements\r\n",
      "  domainSize: 2                                \r\n",
      "    identity: [1, 2]                           \r\n",
      "      parent: Permutations acting on 2 elements\r\n",
      "generator(1): [2, 1]                           \r\n",
      "\r\n",
      "outputRep =\r\n",
      "\r\n",
      "Orthogonal real representation of dimension 2\r\n",
      "    dimension: 2                                \r\n",
      "        field: 'R'                              \r\n",
      "        group: Permutations acting on 2 elements\r\n",
      "inverseImages: {[0, 1; 1, 0]}                   \r\n",
      "    isUnitary: true                             \r\n",
      "    images{1}: [0, 1; 1, 0]                     \r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "outputGroup = replab.S(2)\n",
    "outputRep = outputGroup.definingRep"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Adding the relabelings of inputs\n",
    "\n",
    "In the CHSH scenario, each party has two binary measurements. Therefore,\n",
    "a copy of $S_2$ acts on the outputs of the first measurement, and a second\n",
    "copy of $S_2$ acting on the outputs of the second measurement, while\n",
    "another copy of $S_2$ permutes the choice of measurement (input).\n",
    "\n",
    "This is described by the wreath product of $S_2$ by $S_2$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ioGroup =\r\n",
      "\r\n",
      "replab.wreathproduct.OfNiceFiniteGroup\r\n",
      "           A: Permutations acting on 2 elements      \r\n",
      "           H: Permutations acting on 2 elements      \r\n",
      "           N: replab.directproduct.OfNiceFiniteGroups\r\n",
      "    identity: {[1, 2], {[1, 2], [1, 2]}}             \r\n",
      "           n: 2                                      \r\n",
      "      parent: replab.wreathproduct.OfNiceFiniteGroup \r\n",
      "         phi: replab.perm.PermutationCellAction      \r\n",
      "generator(1): {[2, 1], {[1, 2], [1, 2]}}             \r\n",
      "generator(2): {[1, 2], {[2, 1], [1, 2]}}             \r\n",
      "generator(3): {[1, 2], {[1, 2], [2, 1]}}             \r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "ioGroup = replab.S(2).wreathProduct(outputGroup)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The representation on the conditional probility $P(a|x)$ is the\n",
    "imprimitive representation, given that we use the defining representation\n",
    "for the inner group"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "ioRep = ioGroup.imprimitiveRep(outputRep);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Adding the relabelings of parties\n",
    "\n",
    "The same story repeats for relabelings of parties: the scenario involves\n",
    "two homogeneous parties. We thus have two copies of the group relabeling\n",
    "inputs and/or outputs (one for Alice, one for Bob), and a copy of $S_2$ that\n",
    "permutes the parties. This group desribing all possible relabellings in\n",
    "this scenario is thus given by:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "scenarioGroup = outputGroup.wreathProduct(ioGroup);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The representation on the behavior $P(ab|xy)$ is however a primitive\n",
    "representation, as $P(a|x; b|y)$ ressembles a tensor. Inside each party,\n",
    "we use the imprimitive representation constructed before."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "probRep = scenarioGroup.primitiveRep(ioRep);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Decomposition of the full probability space\n",
    "\n",
    "We can now compute the decomposition of this representation on $P(ab|xy)$:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "dec =\r\n",
      "\r\n",
      "Subrepresentation\r\n",
      "   dimension: 16                                                            \r\n",
      "       field: 'R'                                                           \r\n",
      "       group: replab.wreathproduct.OfNiceFiniteGroup                        \r\n",
      "   irrepInfo: []                                                            \r\n",
      "   isUnitary: true                                                          \r\n",
      "   niceBasis: replab.NiceBasis                                              \r\n",
      "      parent: Orthogonal real representation of dimension 16                \r\n",
      "      U(1,:): [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]/4            \r\n",
      "      U(2,:): [2, 2, -2, -2, 2, 2, -2, -2, -2, -2, 2, 2, -2, -2, 2, 2]/8    \r\n",
      "      U(3,:): [0, 0, -4, -4, 0, 0, -4, -4, 4, 4, 0, 0, 4, 4, 0, 0]/sqrt(128)\r\n",
      "      U(4,:): [4, 4, 0, 0, 4, 4, 0, 0, 0, 0, -4, -4, 0, 0, -4, -4]/sqrt(128)\r\n",
      "      U(5,:): [1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1]/4    \r\n",
      "      U(6,:): [0, 0, -4, 4, 0, 0, 4, -4, 4, -4, 0, 0, -4, 4, 0, 0]/sqrt(128)\r\n",
      "      U(7,:): [4, -4, 0, 0, -4, 4, 0, 0, 0, 0, -4, 4, 0, 0, 4, -4]/sqrt(128)\r\n",
      "      U(8,:): [2, -2, -2, 2, -2, 2, 2, -2, -2, 2, 2, -2, 2, -2, -2, 2]/8    \r\n",
      "      U(9,:): [0, 4, -4, 0, -4, 0, 0, 4, 4, 0, 0, -4, 0, -4, 4, 0]/sqrt(128)\r\n",
      "     U(10,:): [4, 0, 0, -4, 0, -4, 4, 0, 0, 4, -4, 0, -4, 0, 0, 4]/sqrt(128)\r\n",
      "     U(11,:): [2, -2, -2, 2, 2, -2, -2, 2, -2, 2, 2, -2, -2, 2, 2, -2]/8    \r\n",
      "     U(12,:): [2, 2, -2, -2, -2, -2, 2, 2, -2, -2, 2, 2, 2, 2, -2, -2]/8    \r\n",
      "     U(13,:): [0, -4, -4, 0, 4, 0, 0, 4, 4, 0, 0, 4, 0, -4, -4, 0]/sqrt(128)\r\n",
      "     U(14,:): [4, 0, 0, 4, 0, -4, -4, 0, 0, -4, -4, 0, 4, 0, 0, 4]/sqrt(128)\r\n",
      "     U(15,:): [2, 2, 2, 2, -2, -2, -2, -2, 2, 2, 2, 2, -2, -2, -2, -2]/8    \r\n",
      "...\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "dec = probRep.decomposition"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There are 6 irreducible components"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =  6\r\n"
     ]
    }
   ],
   "source": [
    "dec.nComponents"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "These components correspond to the following physical elements ( see [arXiv:1610.01833](https://arxiv.org/abs/1610.01833) ) for more details:\n",
    "\n",
    "- The global normalization of probabilities\n",
    "- The difference of normalization between $x=y$ and $x\\ne y$\n",
    "- The difference of normalization between $x=0$ and $x=1$\n",
    "- The signaling between Alice and Bob\n",
    "- The marginal probabilities of Alice and Bob\n",
    "- The correlation between Alice and Bob"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "-all",
   "notebook_metadata_filter": "-all",
   "text_representation": {
    "extension": ".m",
    "format_name": "light"
   }
  },
  "kernelspec": {
   "display_name": "Octave",
   "language": "octave",
   "name": "octave"
  },
  "language_info": {
   "file_extension": ".m",
   "help_links": [
    {
     "text": "GNU Octave",
     "url": "https://www.gnu.org/software/octave/support.html"
    },
    {
     "text": "Octave Kernel",
     "url": "https://github.com/Calysto/octave_kernel"
    },
    {
     "text": "MetaKernel Magics",
     "url": "https://metakernel.readthedocs.io/en/latest/source/README.html"
    }
   ],
   "mimetype": "text/x-octave",
   "name": "octave",
   "version": "4.2.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
