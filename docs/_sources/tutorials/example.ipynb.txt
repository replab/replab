{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Short overview of some basic features of RepLAB"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Before using *RepLAB* commands, we must first initialize the library:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Adding RepLAB to the path\r\n",
      "warning: function /home/denis/w/replab/src/help.m shadows a core library function\r\n",
      "Adding RepLAB package to the path\r\n",
      "Adding VPI to the path\r\n",
      "Adding MOxUnit to the path\r\n",
      "Adding embedded YALMIP to the path\r\n",
      "Adding embedded SDPT3 solver to the path\r\n",
      "Adding MOcov to the path\r\n"
     ]
    }
   ],
   "source": [
    "run ../../replab_init"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Permutation groups\n",
    "\n",
    "*RepLAB* decomposes representations of permutation groups; this does not lose generality as all finite groups can be represented\n",
    "by permutation groups.\n",
    "\n",
    "We construct the symmetric group acting on $n=4$ elements."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "n = 4;"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The symmetric group is generated by a cyclic permutation $g_1$:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "g1 = [2:n 1];"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "and one transposition $g_2$:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "g2 = [2 1 3:n];"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Remark that permutations in *RepLAB* are simply row vectors of images. We use the convention that permutations act on indices\n",
    "$i=1,2,3,4$ *on the left*, thus the image of 3 under $g_2$ is compatible with MATLAB syntax:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =  3\r\n"
     ]
    }
   ],
   "source": [
    "g2(3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We construct the group by first accessing the group of permutations on 4 elements, then constructing a subgroup"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "S4 =\r\n",
      "\r\n",
      "replab.PermutationSubgroup\r\n",
      "  domainSize: 4                                \r\n",
      "    identity: [1, 2, 3, 4]                     \r\n",
      "      parent: Permutations acting on 4 elements\r\n",
      "generator(1): [2, 3, 4, 1]                     \r\n",
      "generator(2): [2, 1, 3, 4]                     \r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "S4 = replab.Permutations(4).subgroup({g1 g2})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "noting that the generators of the group are named $a$, $b$,...\n",
    "\n",
    "We can perform a few operations on finite groups. Let $g$ be a random permutation, which we can obtain in (mostly) equivalent ways by either"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "g = randperm(n);\n",
    "g = S4.sample;\n",
    "g = S4.sampleUniformly;"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can also compute the group order or enumerate the elements of the group"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "    24\r\n"
     ]
    }
   ],
   "source": [
    "S4.order"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "Indexed family of 24 elements\r\n",
      "   1 = [1, 2, 3, 4]    \r\n",
      "   2 = [1, 4, 3, 2]    \r\n",
      "   3 = [1, 4, 2, 3]    \r\n",
      "   4 = [1, 3, 2, 4]    \r\n",
      "   5 = [1, 2, 4, 3]    \r\n",
      "   6 = [1, 3, 4, 2]    \r\n",
      "   7 = [3, 4, 1, 2]    \r\n",
      "   8 = [3, 2, 1, 4]    \r\n",
      "   9 = [3, 2, 4, 1]    \r\n",
      "  10 = [3, 1, 4, 2]    \r\n",
      "  11 = [3, 4, 2, 1]    \r\n",
      ".. 2   elements omitted\r\n",
      "  14 = [2, 1, 4, 3]    \r\n",
      "  15 = [2, 1, 3, 4]    \r\n",
      "  16 = [2, 4, 3, 1]    \r\n",
      "  17 = [2, 3, 1, 4]    \r\n",
      "  18 = [2, 4, 1, 3]    \r\n",
      "  19 = [4, 1, 2, 3]    \r\n",
      "  20 = [4, 3, 2, 1]    \r\n",
      "  21 = [4, 3, 1, 2]    \r\n",
      "  22 = [4, 2, 1, 3]    \r\n",
      "  23 = [4, 1, 3, 2]    \r\n",
      "  24 = [4, 2, 3, 1]    \r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "S4.elements"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "... a technique that works even for big groups ..."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "S30 =\r\n",
      "\r\n",
      "replab.PermutationSubgroup\r\n",
      "  domainSize: 30                                \r\n",
      "    identity: 1 x 30 double                     \r\n",
      "      parent: Permutations acting on 30 elements\r\n",
      "generator(1): 1 x 30 double                     \r\n",
      "generator(2): 1 x 30 double                     \r\n",
      "\r\n",
      "ans =\r\n",
      "    265252859812191058636308480000000\r\n"
     ]
    }
   ],
   "source": [
    "S30 = replab.Permutations(30).subgroup({[2:30 1] [2 1 3:30]})\n",
    "S30.order"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "Indexed family of 265252859812191058636308480000000 elements\r\n",
      "                                   1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...\r\n",
      "                                   2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...\r\n",
      "                                   3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...\r\n",
      "                                   4 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...\r\n",
      "                                   5 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...\r\n",
      "                                   6 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...\r\n",
      "                                   7 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...\r\n",
      "                                   8 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...\r\n",
      "                                   9 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...\r\n",
      "                                  10 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...\r\n",
      "                                  11 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...\r\n",
      ".. 265252859812191058636308479999978   elements omitted                         \r\n",
      "   265252859812191058636308479999990 = [30, 29, 5, 23, 22, 1, 2, 21, 13, 19, ...\r\n",
      "   265252859812191058636308479999991 = [30, 29, 5, 23, 22, 1, 2, 21, 13, 19, ...\r\n",
      "   265252859812191058636308479999992 = [30, 29, 5, 23, 22, 1, 2, 21, 13, 19, ...\r\n",
      "   265252859812191058636308479999993 = [30, 29, 5, 23, 22, 1, 2, 21, 13, 19, ...\r\n",
      "   265252859812191058636308479999994 = [30, 29, 5, 23, 22, 1, 2, 21, 13, 19, ...\r\n",
      "   265252859812191058636308479999995 = [30, 29, 5, 23, 22, 1, 2, 21, 13, 19, ...\r\n",
      "   265252859812191058636308479999996 = [30, 29, 5, 23, 22, 1, 2, 21, 13, 19, ...\r\n",
      "   265252859812191058636308479999997 = [30, 29, 5, 23, 22, 1, 2, 21, 13, 19, ...\r\n",
      "   265252859812191058636308479999998 = [30, 29, 5, 23, 22, 1, 2, 21, 13, 19, ...\r\n",
      "   265252859812191058636308479999999 = [30, 29, 5, 23, 22, 1, 2, 21, 13, 19, ...\r\n",
      "   265252859812191058636308480000000 = [30, 29, 5, 23, 22, 1, 2, 21, 13, 19, ...\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "S30.elements"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The representation of a group\n",
    "\n",
    "The defining representation of $S_4$ simply permutes the coordinates of $R^4$:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "rho =\r\n",
      "\r\n",
      "Orthogonal real representation of dimension 4\r\n",
      "    dimension: 4                                               \r\n",
      "        field: 'R'                                             \r\n",
      "        group: replab.PermutationSubgroup                      \r\n",
      "inverseImages: 1 x 2 cell                                      \r\n",
      "    isUnitary: true                                            \r\n",
      "    images{1}: [0, 0, 0, 1; 1, 0, 0, 0; 0, 1, 0, 0; 0, 0, 1, 0]\r\n",
      "    images{2}: [0, 1, 0, 0; 1, 0, 0, 0; 0, 0, 1, 0; 0, 0, 0, 1]\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "rho = S4.definingRep"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We take two elements of $S_4$:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "g =\r\n",
      "\r\n",
      "   2   3   1   4\r\n",
      "\r\n",
      "h =\r\n",
      "\r\n",
      "   2   1   4   3\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "g = [2 3 1 4]\n",
    "h = [2 1 4 3]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "and their composition"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "gh =\r\n",
      "\r\n",
      "   3   2   4   1\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "gh = g(h)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "and verify that we have a representation of the group"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "   0   0   0   1\r\n",
      "   0   1   0   0\r\n",
      "   1   0   0   0\r\n",
      "   0   0   1   0\r\n",
      "\r\n",
      "ans =\r\n",
      "\r\n",
      "   0   0   0   1\r\n",
      "   0   1   0   0\r\n",
      "   1   0   0   0\r\n",
      "   0   0   1   0\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "rho.image(g) * rho.image(h)\n",
    "rho.image(gh)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can also define representations from their images. Here, we define the sign representation (using a permutation representation of it!). "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "rho1 =\r\n",
      "\r\n",
      "Orthogonal real representation of dimension 2\r\n",
      "    dimension: 2                           \r\n",
      "        field: 'R'                         \r\n",
      "        group: replab.PermutationSubgroup  \r\n",
      "inverseImages: {[0, 1; 1, 0], [0, 1; 1, 0]}\r\n",
      "    isUnitary: true                        \r\n",
      "    images{1}: [0, 1; 1, 0]                \r\n",
      "    images{2}: [0, 1; 1, 0]                \r\n",
      "\r\n",
      "rho2 =\r\n",
      "\r\n",
      "Orthogonal real representation of dimension 2\r\n",
      "    dimension: 2                           \r\n",
      "        field: 'R'                         \r\n",
      "        group: replab.PermutationSubgroup  \r\n",
      "inverseImages: {[0, 1; 1, 0], [0, 1; 1, 0]}\r\n",
      "    isUnitary: true                        \r\n",
      "    images{1}: [0, 1; 1, 0]                \r\n",
      "    images{2}: [0, 1; 1, 0]                \r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "dim = 2;\n",
    "isUnitary = true;\n",
    "rho1 = S4.repByImages('R', dim, isUnitary, {[0 1; 1 0] [0 1; 1 0]})\n",
    "rho2 = S4.permutationRep(2, {[2 1] [2 1]})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "   1   0\r\n",
      "   0   1\r\n",
      "\r\n",
      "ans =\r\n",
      "\r\n",
      "   1   0\r\n",
      "   0   1\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "rho1.image(g)\n",
    "rho2.image(g)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The decompositions of a representation\n",
    "*RepLAB* provides the irreducible decomposition of representations over the real numbers, identifying the representation type (real, complex or quaternionic):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "I =\r\n",
      "\r\n",
      "Subrepresentation\r\n",
      "   dimension: 4                                            \r\n",
      "       field: 'R'                                          \r\n",
      "       group: replab.PermutationSubgroup                   \r\n",
      "   irrepInfo: []                                           \r\n",
      "   isUnitary: true                                         \r\n",
      "   niceBasis: replab.NiceBasis                             \r\n",
      "      parent: Orthogonal real representation of dimension 4\r\n",
      "      U(1,:): [1, 1, 1, 1]/2                               \r\n",
      "      U(2,:): [1, -1, -1, 1]/2                             \r\n",
      "      U(3,:): [1, 1, -1, -1]/2                             \r\n",
      "      U(4,:): [1, -1, 1, -1]/2                             \r\n",
      "component(1): Isotypic component R(1)                      \r\n",
      "component(2): Isotypic component R(3)                      \r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "I = rho.decomposition"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can get isotypic components and the copies of irreducible representations contained inside"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "Isotypic component R(1)\r\n",
      "     dimension: 1                                              \r\n",
      "         field: 'R'                                            \r\n",
      "         group: replab.PermutationSubgroup                     \r\n",
      "irrepDimension: 1                                              \r\n",
      "     irrepInfo: []                                             \r\n",
      "     isUnitary: true                                           \r\n",
      "  multiplicity: 1                                              \r\n",
      "     niceBasis: replab.NiceBasis                               \r\n",
      "        parent: Orthogonal real representation of dimension 4  \r\n",
      "        U(1,:): [1, 1, 1, 1]/2                                 \r\n",
      "      irrep(1): Real irreducible subrepresentation of real type\r\n",
      "\r\n",
      "subrho1 =\r\n",
      "\r\n",
      "Real irreducible subrepresentation of real type\r\n",
      "dimension: 1                                            \r\n",
      "    field: 'R'                                          \r\n",
      "    group: replab.PermutationSubgroup                   \r\n",
      "irrepInfo: irreducible, '1', real of real type          \r\n",
      "isUnitary: true                                         \r\n",
      "niceBasis: replab.NiceBasis                             \r\n",
      "   parent: Orthogonal real representation of dimension 4\r\n",
      "   U(1,:): [1, 1, 1, 1]/2                               \r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "I.component(1)\n",
    "subrho1 = I.component(1).irrep(1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "Isotypic component R(3)\r\n",
      "     dimension: 3                                              \r\n",
      "         field: 'R'                                            \r\n",
      "         group: replab.PermutationSubgroup                     \r\n",
      "irrepDimension: 3                                              \r\n",
      "     irrepInfo: []                                             \r\n",
      "     isUnitary: true                                           \r\n",
      "  multiplicity: 1                                              \r\n",
      "     niceBasis: replab.NiceBasis                               \r\n",
      "        parent: Orthogonal real representation of dimension 4  \r\n",
      "        U(1,:): [1, -1, -1, 1]/2                               \r\n",
      "        U(2,:): [1, 1, -1, -1]/2                               \r\n",
      "        U(3,:): [1, -1, 1, -1]/2                               \r\n",
      "      irrep(1): Real irreducible subrepresentation of real type\r\n",
      "\r\n",
      "subrho2 =\r\n",
      "\r\n",
      "Real irreducible subrepresentation of real type\r\n",
      "dimension: 3                                            \r\n",
      "    field: 'R'                                          \r\n",
      "    group: replab.PermutationSubgroup                   \r\n",
      "irrepInfo: irreducible, real of real type               \r\n",
      "isUnitary: true                                         \r\n",
      "niceBasis: replab.NiceBasis                             \r\n",
      "   parent: Orthogonal real representation of dimension 4\r\n",
      "   U(1,:): [1, -1, -1, 1]/2                             \r\n",
      "   U(2,:): [1, 1, -1, -1]/2                             \r\n",
      "   U(3,:): [1, -1, 1, -1]/2                             \r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "I.component(2)\n",
    "subrho2 = I.component(2).irrep(1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "with their bases:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "Compressed Column Sparse (rows = 1, cols = 4, nnz = 4 [100%])\r\n",
      "\r\n",
      "  (1, 1) ->  0.50000\r\n",
      "  (1, 2) ->  0.50000\r\n",
      "  (1, 3) ->  0.50000\r\n",
      "  (1, 4) ->  0.50000\r\n",
      "\r\n",
      "ans =\r\n",
      "\r\n",
      "   0.50000  -0.50000  -0.50000   0.50000\r\n",
      "   0.50000   0.50000  -0.50000  -0.50000\r\n",
      "   0.50000  -0.50000   0.50000  -0.50000\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "subrho1.U\n",
    "subrho2.U"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The commutant algebra\n",
    "\n",
    "The commutant algebra of $\\rho$ is composed of all the matrices $M$ that commute with $\\rho$, that is $M \\rho_g = \\rho_g M$ for all $g$ in the group.\n",
    "\n",
    "*RepLAB* gives an access to that algebra:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "C =\r\n",
      "\r\n",
      "replab.CommutantFromEquivariant\r\n",
      " field: 'R'                                          \r\n",
      " group: replab.PermutationSubgroup                   \r\n",
      "     n: 4                                            \r\n",
      "parent: 4 x 4 real matrices                          \r\n",
      "   rep: Orthogonal real representation of dimension 4\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "C = rho.commutant"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "and we can sample generic matrices from that algebra"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "   0.79053   0.15074   0.15074   0.15074\r\n",
      "   0.15074   0.79053   0.15074   0.15074\r\n",
      "   0.15074   0.15074   0.79053   0.15074\r\n",
      "   0.15074   0.15074   0.15074   0.79053\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "C.sample"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "or perform an orthogonal projection of arbitrary matrices in that algebra"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mgen =\r\n",
      "\r\n",
      "   0.762814   0.064514   0.629743   0.476722\r\n",
      "   0.765906   0.823069   0.295183   0.612500\r\n",
      "   0.576125   0.198434   0.593103   0.434332\r\n",
      "   0.334787   0.555980   0.912773   0.465875\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "Mgen = rand(n, n)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "M =\r\n",
      "\r\n",
      "   0.41288   0.59255   0.59255   0.59255\r\n",
      "   0.59255   0.41288   0.59255   0.59255\r\n",
      "   0.59255   0.59255   0.41288   0.59255\r\n",
      "   0.59255   0.59255   0.59255   0.41288\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "M = C.project(rand(n,n))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "which is has a block diagonalization in the symmetry adapted basis:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "U =\r\n",
      "\r\n",
      "Compressed Column Sparse (rows = 4, cols = 4, nnz = 16 [100%])\r\n",
      "\r\n",
      "  (1, 1) ->  0.50000\r\n",
      "  (2, 1) ->  0.50000\r\n",
      "  (3, 1) ->  0.50000\r\n",
      "  (4, 1) ->  0.50000\r\n",
      "  (1, 2) ->  0.50000\r\n",
      "  (2, 2) -> -0.50000\r\n",
      "  (3, 2) ->  0.50000\r\n",
      "  (4, 2) -> -0.50000\r\n",
      "  (1, 3) ->  0.50000\r\n",
      "  (2, 3) -> -0.50000\r\n",
      "  (3, 3) -> -0.50000\r\n",
      "  (4, 3) ->  0.50000\r\n",
      "  (1, 4) ->  0.50000\r\n",
      "  (2, 4) ->  0.50000\r\n",
      "  (3, 4) -> -0.50000\r\n",
      "  (4, 4) -> -0.50000\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "U = I.U"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ans =\r\n",
      "\r\n",
      "   2.19054   0.00000   0.00000   0.00000\r\n",
      "   0.00000  -0.17967  -0.00000   0.00000\r\n",
      "  -0.00000   0.00000  -0.17967  -0.00000\r\n",
      "  -0.00000   0.00000   0.00000  -0.17967\r\n",
      "\r\n"
     ]
    }
   ],
   "source": [
    "U*M*U'"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "-all",
   "notebook_metadata_filter": "-all",
   "text_representation": {
    "extension": ".m",
    "format_name": "light"
   }
  },
  "kernelspec": {
   "display_name": "Octave",
   "language": "octave",
   "name": "octave"
  },
  "language_info": {
   "file_extension": ".m",
   "help_links": [
    {
     "text": "GNU Octave",
     "url": "https://www.gnu.org/software/octave/support.html"
    },
    {
     "text": "Octave Kernel",
     "url": "https://github.com/Calysto/octave_kernel"
    },
    {
     "text": "MetaKernel Magics",
     "url": "https://metakernel.readthedocs.io/en/latest/source/README.html"
    }
   ],
   "mimetype": "text/x-octave",
   "name": "octave",
   "version": "4.2.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
