%% Short RepLAB tutorial
%
% This document will show some features of *RepLAB*.

%%
% Before trying any of the *RepLAB* commands, we must first add the paths:
replab_addpaths

%% Working with permutation groups
% *RepLAB* decomposes representations of permutation groups; this
% does not lose generality as all finite groups can be represented
% by permutation groups.
%
% We construct the symmetric group acting on $n=4$ elements.
n = 4;
%%
% The symmetric group is generated by a cyclic permutation $g_1$:
g1 = [2:n 1];
%%
% and one transposition $g_2$:
g2 = [2 1 3:n];
%%
% Remark that permutations in *RepLAB* are simply row vectors of
% images. We use the convention that permutations act on indices
% $i=1,2,3,4$ *on the left*, thus the image of 3 under $g_2$
% is compatible with MATLAB syntax:
g2(3)
%%
% We construct the group by first accessing the group of
% permutations on 4 elements, then constructing a subgroup
S4 = replab.Permutations(4).subgroup({g1 g2})
%%
% noting that the generators of the group are named $a$, $b$,...
%
% We can perform a few operations on finite groups. Let $g$ be a
% random permutation, which we can obtain in (mostly) equivalent ways by either
g = randperm(n);
g = S4.sample;
g = S4.sampleUniformly;
%%
% But for the example, we fix the random sample.
g = [3 2 4 1]
%%
% We can factor the last $g$ in the group generators:
w = S4.factorization(g)
%%
% to obtain a word in the generators $a$ and $b$. We evaluate back
% this word:
g1 = S4.evaluateWord(w)
%%
% to obtain back $g$.
%
% We can also compute the group order or enumerate the elements of
% the group
S4.order
%%
%
S4.elements
%%
% a technique that works even for big groups.
S30 = replab.Permutations(30).subgroup({[2:30 1] [2 1 3:30]})
S30.order
%%
%
S30.elements


%% Group representations
% The natural representation of $S_4$ simply permutes the
% coordinates of $R^4$:
rho = S4.naturalRepresentation
%%
% We take two elements of $S_4$:
g = [2 3 1 4]
h = [2 1 4 3]
%%
% and their composition
gh = g(h)
%%
% and verify that we have a representation of the group
rho.image(g) * rho.image(h)
rho.image(gh)
%%
% We can also define representations from their images. Here,
% we define the sign representation (using a permutation
% representation of it!).
dim = 2;
rho1 = S4.realRepresentation(dim, {[0 1; 1 0] [0 1; 1 0]})
rho2 = S4.permutationRepresentation(2, {[2 1] [2 1]})
%%
%
rho1.image(g)
rho2.image(g)

%% Decomposing group representations
% *RepLAB* provides the irreducible decomposition of representations
% over the real numbers, identifying the representation type
% (real, complex or quaternionic):
rho.irreducible
%%
% We can get subrepresentations
subrho1 = rho.irreducible.component(1)
%%
%
subrho2 = rho.irreducible.component(2)
%%
% with their bases:
subrho1.U
subrho2.U

%% The centralizer algebra
% The centralizer algebra of $\rho$ is composed of all the matrices
% $M$ that commute with $\rho$, that is $M \rho_g = \rho_g M$ for
% all $g$ in the group.
%
% *RepLAB* gives an access to that algebra:
A = rho.centralizerAlgebra
%%
% and we can sample generic matrices from that algebra
%
A.sample
%%
% or perform an orthogonal projection of arbitrary matrices in that
% algebra
Mgen = rand(n, n)
%%
%
M = A.project(rand(n,n))
%%
% Now, given $M$ in the algebra, we can get its blocks:
blocks = rho.irreducible.centralizerAlgebra.blocksOfParentElement(M)
%%
% which correspond to the block diagonalization of such matrices in
% the symmetry adapted basis:
U = rho.irreducible.U
%%
%
U'*M*U