%% Short RepLAB tutorial
%
% This document will show some features of *RepLAB*.

%%
% Before trying any of the *RepLAB* commands, we must first add the paths:
replab_addpaths

%% Working with permutation groups
% *RepLAB* decomposes representations of permutation groups; this
% does not lose generality as all finite groups can be represented
% by permutation groups.
%
% We construct the symmetric group acting on $n=4$ elements.
n = 4;
%%
% The symmetric group is generated by a cyclic permutation $g_1$:
g1 = [2:n 1];
%%
% and one transposition $g_2$:
g2 = [2 1 3:n];
%%
% Remark that permutations in *RepLAB* are simply row vectors of
% images. We use the convention that permutations act on indices
% $i=1,2,3,4$ *on the left*, thus the image of 3 under $g_2$
% is compatible with MATLAB syntax:
g2(3)
%%
% We construct the group by first accessing the group of
% permutations on 4 elements, then constructing a subgroup
S4 = replab.Permutations(4).subgroup({g1 g2})
%%
% noting that the generators of the group are named $a$, $b$,...
%
% We can perform a few operations on finite groups. Let $g$ be a
% random permutation, which we can obtain in (mostly) equivalent ways by either
g = randperm(n);
g = S4.sample;
g = S4.sampleUniformly;
%
% We can also compute the group order or enumerate the elements of
% the group
S4.order
%%
%
S4.elements
%%
% a technique that works even for big groups.
S30 = replab.Permutations(30).subgroup({[2:30 1] [2 1 3:30]})
S30.order
%%
%
S30.elements


%% Group representations
% The natural representation of $S_4$ simply permutes the
% coordinates of $R^4$:
rho = S4.naturalRep
%%
% We take two elements of $S_4$:
g = [2 3 1 4]
h = [2 1 4 3]
%%
% and their composition
gh = g(h)
%%
% and verify that we have a representation of the group
rho.image(g) * rho.image(h)
rho.image(gh)
%%
% We can also define representations from their images. Here,
% we define the sign representation (using a permutation
% representation of it!). 
dim = 2;
isUnitary = true;
rho1 = S4.rep('R', dim, isUnitary, {[0 1; 1 0] [0 1; 1 0]})
rho2 = S4.permutationRep(2, {[2 1] [2 1]})
%%
%
rho1.image(g)
rho2.image(g)

%% Decomposing group representations
% *RepLAB* provides the irreducible decomposition of representations
% over the real numbers, identifying the representation type
% (real, complex or quaternionic):
I = rho.decomposition
%%
% We can get isotypic components and the copies of irreducible
% representations contained inside
I.component(1)
subrho1 = I.component(1).copy(1)
%%
%
I.component(2)
subrho2 = I.component(2).copy(1)
%%
% with their bases:
subrho1.U
subrho2.U

%% The commutant algebra
% The commutant algebra of $\rho$ is composed of all the matrices
% $M$ that commute with $\rho$, that is $M \rho_g = \rho_g M$ for
% all $g$ in the group.
%
% *RepLAB* gives an access to that algebra:
C = rho.commutant
%%
% and we can sample generic matrices from that algebra
%
C.sample
%%
% or perform an orthogonal projection of arbitrary matrices in that
% algebra
Mgen = rand(n, n)
%%
%
M = C.project(rand(n,n))
%%
%%
% Which is has a block diagonalization in the symmetry adapted basis:
U = I.rep.U
%%
%
U*M*U'
