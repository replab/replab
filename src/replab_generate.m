function replab_generate(what)
% Code generation function
%
% Depending on the value of the argument ``what``:
%
% - ``all`` regenerates all generated code/documentation
%
% - ``clear`` clears out all directories with autogenerated code/doc
%
% - ``sphinxsrc`` preprocesses the RepLAB source code to complement the
%   `Sphinx Matlab domain <https://github.com/sphinx-contrib/matlabdomain>`_ job.
%   It generates a table of contents for all source code files, generates method and
%   property occurences for inherited members, shifts the documentation of properties to
%   be explicit (to support multiline documentation and types).
%   It also copies the source files at the root of the source folder in a ``root`` subdirectory
%   so that the Sphinx Matlab domain has a "module" name for those.
%
% - ``sphinxjupyter`` processes the Jupyter notebooks in the Sphinx directory. Care must be taken
%   to not run the Matlab kernel inside Jupyter inside a running Matlab session. All our tutorials
%   are run indeed by the octave kernel.
%
% - ``sphinxbuild`` runs the Sphinx documentation generation.
%
% - ``sphinx`` runs all the Sphinx generation steps.
%
% - ``doctests`` extracts the doctests from the source code and writes them to the doctests code folder.
%
% Args:
%   what ({'clear', 'sphinx*', 'sphinx', 'doctests', 'all'}, optional): What to generate, default ``'all'``

    if nargin < 1
        what = 'all';
    end

    logFun = @(str) disp(str);
    valid = {'sphinx' 'sphinxbuild' 'sphinxsrc' 'sphinxjupyter' 'doctests' 'all'};
    validStr = strjoin(cellfun(@(x) sprintf('''%s''', x), valid, 'uniform', 0), ', ');
    assert(ismember(what, valid), 'Argument must be one of: %s', validStr);

    rp = replab.settings.replabPath;
    srcRoot = fullfile(rp, 'src');

    disp('Crawling code base');
    cb = replab.infra.crawl(srcRoot);

    if isequal(what, 'sphinxjupyter') || isequal(what, 'sphinx') || isequal(what, 'all') || isequal(what, 'clear')
        toExplore = {{'sphinx'}};
        notebooks = {};
        sourceSuffix = '_source.ipynb';
        targetSuffix = '.ipynb';
        while length(toExplore) > 0
            subpath = toExplore{1};
            toExplore = toExplore(2:end);
            path = fullfile(rp, subpath{:});
            children = dir(path);
            for i = 1:length(children)
                name = children(i).name;
                if isequal(name, '.') || isequal(name, '..')
                    % do nothing
                elseif children(i).isdir
                    % new folder
                    toExplore{1,end+1} = horzcat(subpath, {name});
                else
                    if replab.compat.endsWith(name, sourceSuffix)
                        notebooks{1,end+1} = strjoin(horzcat(subpath, {name}), filesep);
                    end
                end
            end
        end
        lastPath = pwd;
        for i = 1:length(notebooks)
            source = notebooks{i};
            [~, sourceName, sourceExt] = fileparts(source);
            target = [sourceName sourceExt];
            target = [target(1:end-length(sourceSuffix)) targetSuffix];
            if isequal(what, 'clear')
                if exist(target) == 2
                    delete(target);
                end
            else
                cmd = sprintf('jupyter nbconvert --to notebook --execute "%s" --output="%s"', source, target);
                disp(['Running ' cmd]);
                system(cmd);
            end
        end
        cd(lastPath);
    end

    if isequal(what, 'sphinxsrc') || isequal(what, 'sphinx') || isequal(what, 'all') || isequal(what, 'clear')
        % Generate Sphinx preprocessed source files
        srcRoot = fullfile(rp, 'src');
        sphinxRoot = fullfile(rp, 'sphinx');
        sphinxSrcRoot = fullfile(sphinxRoot, '_src');
        replab.infra.mkCleanDir(sphinxRoot, '_src', logFun);
        if ~isequal(what, 'clear')
            logFun('Generating rich source code');
            els = cb.allSourceElements;
            pb = replab.infra.repl.ProgressBar(length(els));
            for i = 1:length(els)
                pb.step(i, els{i}.fullIdentifier);
                replab.infra.sphinx.writeEnrichedSource(sphinxSrcRoot, els{i});
            end
            pb.finish;
            % Copy root files from the root source folder to a subfolder named 'root'
            mkdir(sphinxSrcRoot, 'root');
            files = dir([sphinxSrcRoot filesep '*.m']);
            for i = 1:length(files)
                assert(~files(i).isdir, 'Files ending in .m cannot be directories');
                name = files(i).name;
                copyfile(fullfile(sphinxSrcRoot, name), fullfile(sphinxSrcRoot, 'root', name));
            end
            files = dir([rp filesep '*.m']);
            for i = 1:length(files)
                assert(~files(i).isdir, 'Files ending in .m cannot be directories');
                name = files(i).name;
                copyfile(fullfile(rp, name), fullfile(sphinxSrcRoot, 'root', name));
            end
        end
    end

    if isequal(what, 'sphinxbuild') || isequal(what, 'sphinx') || isequal(what, 'all')
        replab.infra.mkCleanDir(rp, 'docs', logFun);
        if ~isequal(what, 'clear')
            disp('Running Sphinx');
            lastPath = pwd;
            cmd = 'sphinx-build -b html sphinx docs';
            disp(['Running ' cmd]);
            system(cmd);
            cd(lastPath);
        end
    end

    if isequal(what, 'doctests') || isequal(what, 'all') || isequal(what, 'clear')
        % Generate doctests
        testRoot = fullfile(rp, 'tests');
        doctestRoot = fullfile(rp, 'tests', 'doctest');
        replab.infra.mkCleanDir(testRoot, 'doctest');
        if ~isequal(what, 'clear')
            logFun('Generating doctests');
            els = cb.allSourceElements;
            pb = replab.infra.repl.ProgressBar(length(els));
            for i = 1:length(els)
                pb.step(i, els{i}.fullIdentifier);
                replab.infra.doctests.writeElementDocTests(doctestRoot, els{i});
            end
            pb.finish;
        end
    end

end
