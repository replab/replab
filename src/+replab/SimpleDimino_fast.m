function elt_arr = SimpleDimino_fast(generators, group, max_order)
% Returns all elements of the group generated by the given generators
% 
% Dimino's algorithm:
% Butler, Gregory. “List of Elements.” FUNDAMENTAL ALGORITHMS FOR PERMUTATION GROUPS, 
% by Gregory Butler, Springer-Verlag, 1991, pp. 14–23.
% 
% Args:
%   generators (cell array): generating elements of the group
%   group (replab Group object): can be a permutation group, a direct
%                                product group, or an integer matrix group
%   max_order (double, optional): maximum number of elements allowed.
%                                 Should be given for much smaller subgroups
%                                 of permutation or direct product groups
%                                 
% Returns 
%   elements (cell array): all group elements 
%
% Example:
% S3 = replab.S(3)
% replab.SimpleDimino({[2,3,1],[2,1,3]}, S3) returns all elements in the 
%                                               S3 permutation group


%%% Check generators are provided
if isempty(length(generators))
    return
end


%%% Check that none of the generators are the identity
i = 1;
while i <= length(generators)
    if group.eqv(generators{i}, group.identity)
        generators(i) = [];
    end
    i = i+1;
end

%%% Set up matrix depending on type of group
id = group.identity;
if iscell(id) % direct product
    vec = 0; mat = 0; dir_prod = 1;
    vecid = vectorize(id);
    elt_len = length(vecid);
    if nargin == 3
        nelts = max_order;
    else
        nelts = double(group.order);
    end
elseif isvector(id) % permutation
    vec = 1; mat = 0; dir_prod = 0;
    elt_len = length(id);
    if nargin == 3
        nelts = max_order;
    else
        nelts = double(group.order);
    end
elseif ismatrix(id) % integer matrix
    vec = 0; mat = 1; dir_prod = 0;
    dim = size(id);
    elt_len = numel(id);
    if nargin == 3
        nelts = max_order;
    else
        nelts = 1000;
    end
else
    err('Error: data type not accepted')
end
% create matrix to use for fast equality testing
elements = zeros(nelts, elt_len);


%%% simple Dimino's algorithm

% add cyclic group of first generator
order = 1;
if vec
    elements(1, :) = id; 
elseif mat
    elements(1, :) = reshape(id, [1, elt_len]);
else
    elements(1, :) = vecid;
    elt_arr = {id};
end
s1 = generators{1};
g = s1;
% add powers of s1 until getting back to identity
while ~group.eqv(g, id) 
    order = order + 1;
    if vec
        elements(order, :) = g;
    elseif mat
        if order > nelts
            elements = [elements; zeros(1000, elt_len)];
            nelts = nelts + 1000;
        end
        elements(order, :) = reshape(g, [1, elt_len]);
    else
        elements(order, :) = vectorize(g);
        elt_arr{order} = g;
    end
    g = group.compose(g, s1);
end

% inductive steps in algorithm
for i = 2:length(generators)
    s = generators{i};
    if vec
        svec = s;
    elseif mat
        svec = reshape(s, [1, elt_len]);
    else
        svec = vectorize(s);
    end
    % continue if generator s is not already in elements
    if ~any(all(elements - svec == 0, 2))
        prev_order = order;
        order = order + 1;
        elements(order, :) = svec;
            if dir_prod
                elt_arr{order} = s;
            end
        % compose previous elements with new generator
        for j = 2:prev_order
            order = order + 1;
            if vec
                elements(order, :) = group.compose(elements(j, :), s);
            elseif mat
                if order > nelts
                    elements = [elements; zeros(1000, elt_len)];
                    nelts = nelts + 1000;
                end
                mat_elmt = group.compose(reshape(elements(j, :), dim), s);
                elements(order, :) = reshape(mat_elmt, [1, elt_len]);
            else
                dir_elmt = group.compose(elt_arr{j}, s);
                elements(order, :) = vectorize(dir_elmt);
                elt_arr{order} = dir_elmt;
            end
        end

        % use coset to add new elements
        cos_pos = prev_order + 1; % first element in coset is generator s
        while cos_pos <= order
            for n = 1:length(generators)
                sn = generators{n};
                % left multiply the elements of the coset
                if vec
                    elmt = group.compose(elements(cos_pos, :), sn);
                elseif mat
                    if order > nelts
                        elements = [elements; zeros(1000, elt_len)];
                        nelts = nelts + 1000;
                    end
                    mat_elmt = group.compose(reshape(elements(cos_pos, :), dim), sn);
                    elmt = reshape(mat_elmt, [1, elt_len]);
                else
                    dir_elmt = group.compose(elt_arr{cos_pos}, sn);
                    elmt = vectorize(dir_elmt);
                end
                % add elmt to coset if not in elements
                if ~any(all(elements - elmt == 0, 2))
                    order = order + 1;
                    elements(order, :) = elmt;
                    if dir_prod
                        elt_arr{order} = dir_elmt;
                    end
                    % right multiply all previous elements with the new
                    % element in the coset
                    for j = 2:prev_order
                        order = order + 1;
                        if vec
                            elements(order, :) = group.compose(elements(j, :), elmt);
                        elseif mat
                            if order > nelts
                                elements = [elements; zeros(1000, elt_len)];
                                nelts = nelts + 1000;
                            end
                            cos_elmt = group.compose(reshape(elements(j, :), dim), mat_elmt);
                            elements(order, :) = reshape(cos_elmt, [1, elt_len]);
                        else
                            cos_elmt = group.compose(elt_arr{j}, dir_elmt);
                            elements(order, :) = vectorize(cos_elmt);
                            elt_arr{order} = cos_elmt;
                        end
                    end
                end
            end
            % move the coset position to the position of elmt
            cos_pos = cos_pos + prev_order;
        end
        
    end
end


% Convert elements to elt_arr if not a direct product group
if vec
    elt_arr = mat2cell(elements(1:order, :), ones(1, order));
elseif mat
    elt_arr = mat2cell(elements(1:order, :), ones(1, order));
    for i = 1:length(elt_arr)
        elt_arr{i} = reshape(elt_arr{i}, dim);
    end
end

function vector = vectorize(elmt)
    cell_locs = cellfun(@iscell, elmt);
    while any(cell_locs)
        elmt = [elmt(~cell_locs), elmt{cell_locs}];
        cell_locs = cellfun(@iscell, elmt);
    end
    vector = cell2mat(elmt);
end

end
