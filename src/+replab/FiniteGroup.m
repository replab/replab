classdef FiniteGroup < replab.CompactGroup & replab.FiniteSet
% Describes a group with a finite number of elements
%
% A finite group is generated by a finite set of `.generators`.
%
% Groups can be compared for equality using the ``==`` operator.
%
% RepLAB implements group algorithms optimized for permutation groups using the BSGS (base and strong generating set) construction.
%
% Generators and equality
% ~~~~~~~~~~~~~~~~~~~~~~~
%
% The generating set of a group is a property of the group, and is used, for example:
%
% - to factor a group element as a word in the generators,
% - as the default preimages set for representation/morphism construction,
% - to construct an abstract form of the group (see `.relatorsWords`).
%
% However, groups that differ only by their generators are equal as sets. Thus, two groups that are equal under ``==``
% can nevertheless return different values for the methods that work with the group generators.
%
% For display purposes, and to describe group elements as words in the generators, the group generators have
% names `.generatorNames`. Again, groups that differ by the names of their generators are considered mathematically equal.
%
% The exception is `.AbstractGroup` because the generator names are used in the group elements themselves.
%
% Finite group types
% ~~~~~~~~~~~~~~~~~~
%
% Each finite group has a type (`.FiniteGroupType`), that describes the most general group embedding its elements.
% The following are finite group types:
%
% - Permutations acting on ``1 .. n`` (see `.PermutationGroup`)
% - Signed permutations acting on ``+/- 1 .. n`` (see `.SignedPermutationGroup`)
% - Cyclotomic matrices of a given size (note: we restrict the corresponding matrix groups to the finite ones)
% - Product groups of the above (direct, semidirect, wreath)
%
% Finite group methods such as `.contains` can be called with arguments from the group type.
%
% Types can be compared with the `==` operator.
%
% Implementations of finite groups
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%
% `.FiniteGroup` has two main subclasses:
%
% - `.PermutationGroup`, where all the methods are implemented directly using algorithms based on the BSGS construction,
% - `+replab.+gen.FiniteGroup`, which delegate the computations to another group type using an isomorphism.
%
% As of July 2021, generic group implementations delegate computations to permutation groups, but this could evolve in the
% future.
%
% Currently, some delegations of computations assume that the destination group is a permutation group, which is why
% we have `.permutationGroup` and `.permutationIsomorphism` methods on finite groups.

    properties (SetAccess = protected)
        generators % (cell(1,\*) of `.type` elements): Group generators
    end

    methods % Implementations

        % Str

        function [names, values] = additionalFields(self)
            [names, values] = additionalFields@replab.Group(self);
            for i = 1:self.nGenerators
                names{1, end+1} = sprintf('generator(%d or ''%s'')', i, self.generatorNames{i});
                values{1, end+1} = self.generator(i);
            end
            r = self.fastRecognize;
            if ~isempty(r)
                names{1,end+1} = 'recognize.source';
                values{1,end+1} = r.source;
            end
        end

        function names = hiddenFields(self)
            names = hiddenFields@replab.Group(self);
            names{1, end+1} = 'generators';
            names{1, end+1} = 'generatorNames';
            names{1, end+1} = 'type';
            names{1, end+1} = 'representative';
        end

        % Obj

        function l = laws(self)
            l = replab.laws.FiniteGroupLaws(self);
        end

        % Group

        function m = innerAutomorphism(self, by)
            generatorImages = cellfun(@(g) self.leftConjugate(by, g), self.generators, 'uniform', 0);
            m = self.isomorphismByImages(self, 'preimages', self.generators, 'images', generatorImages);
        end

        function m = isomorphismByFunctions(self, target, preimageElementFun, imageElementFun)
            if isa(target, 'replab.FiniteGroup') || isa(target, 'replab.FiniteGroupType')
                m = self.isomorphismByFunction(self, target, imageElementFun, 'preimageElementFun', preimageElementFun);
            else
                m = isomorphismByFunctions@replab.Group(self, target, preimageElementFun, imageElementFun);
            end
        end

        function m = morphismByFunction(self, target, imageElementFun, torusMap)
            if isa(target, 'replab.FiniteGroup')
                imgs = cellfun(imageElementFun, self.generators, 'uniform', 0);
                m = self.morphismByImages(target, 'preimages', self.generators, 'images', imgs, 'imageElementFun', imageElementFun);
            else
                m = morphismByFunction@replab.Group(self, target, imageElementFun, torusMap);
            end
        end

        % CompactGroup

        function b = hasReconstruction(self)
            b = true;
        end

        function d = maximalTorusDimension(self)
            d = 0;
        end

        function [mu, R] = reconstruction(self)
            T = replab.T(0);
            mu = T.morphismByFunction(self, @(t) self.identity);
            R = self.setProduct;
        end

        % FiniteSet

        function g1 = imap(self, f)
            g1 = f.imageGroup(self);
        end

    end

    methods % Conjugacy classes and character table

        function c = characterTable(self)
        % Alias for `.complexCharacterTable`
        %
        % Returns:
        %   `.ComplexCharacterTable`: Complex character table
            c = self.complexCharacterTable;
        end

        function c = complexCharacterTable(self)
        % Returns the complex character table of this group
        %
        % The complex character table is the standard, textbook character table of the group.
        %
        % Note that randomized techniques are used to find group isomorphisms, and thus the output of this
        % method may not be deterministic.
        %
        % Raises:
        %   An error if the character table cannot be computed.
        %
        % Returns:
        %   `.ComplexCharacterTable`: Complex character table
            error('Abstract');
        end

        function c = conjugacyClass(self, g, varargin)
        % Returns the conjugacy class corresponding to the given element
        %
        % Args:
        %   g (element): Arbitrary group element
        %
        % Keywords Args:
        %   isCanonical (logical, optional): Whether the given ``g`` is the class canonical representative, default: false
        %   centralizer (`.FiniteGroup`, optional): Centralizer of the given element
        %
        % Returns:
        %   `.ConjugacyClass`: The conjugacy class containing the given element
            error('Abstract');
        end

        function c = conjugacyClasses(self, varargin)
        % Returns the conjugacy classes of this group
        %
        % Returns:
        %   `.ConjugacyClasses`: Conjugacy classes
            error('Abstract');
        end

        function B = findLeftConjugations(self, s, t, varargin)
        % Returns the set of all elements that left conjugates an element to another element
        %
        % Let ``s`` and ``t`` be two elements of this group. This returns the set of all elements
        % ``b`` such that ``t = b s b^-1`` or ``t = leftConjugate(b, s)``.
        %
        % When no such ``b`` exists, this returns ``[]``.
        %
        % Args:
        %   s (group element): Source element
        %   t (group element): Target element
        %
        % Keyword Args:
        %   sCentralizer (`.FiniteGroup`, optional): Centralizer of ``s`` in this group
        %   tCentralizer (`.FiniteGroup`, optional): Centralizer of ``t`` in this group
        %
        % Returns:
        %   `+replab.LeftCoset` or ``[]``: Set of all elements of this group that left conjugates ``s`` to ``t`` if it exists
            error('Abstract');
        end

        function l = knownComplexCharacterTable(self)
        % Returns whether the complex character table of this group is already known or computed
        %
        % Returns:
        %   logical: Whether the table is already computed
            error('Abstract');
        end

        function l = knownRealCharacterTable(self)
        % Returns whether the real character table of this group is already known or computed
        %
        % Returns:
        %   logical: Whether the table is already computed

            error('Abstract');
        end

        function c = realCharacterTable(self)
        % Returns the real character table of this group
        %
        % Note that randomized techniques are used to find group isomorphisms, and thus the output of this
        % method may not be deterministic.
        %
        % Raises:
        %   An error if the character table cannot be computed.
        %
        % Returns:
        %   `.RealCharacterTable`: Real character table
            error('Abstract');
        end

        function setComplexCharacterTable(self, table)
        % Sets the complex character table of this group
        %
        % Throws an error if this method or `.complexCharacterTable` has already been called before.
        %
        % Args:
        %   table (`.ComplexCharacterTable`): Complex character table
            error('Abstract');
        end

        function setConjugacyClasses(self, classes)
        % Sets the conjugacy classes of this group
        %
        % Throws an error if this method or `.conjugacyClasses` has already been called before.
        %
        % Args:
        %   classes (`.ConjugacyClasses`): Conjugacy classes
            error('Abstract');
        end

        function setRealCharacterTable(self, table)
        % Sets the real character table of this group
        %
        % Throws an error if this method or `.realCharacterTable` has already been called before.
        %
        % Args:
        %   table (`.RealCharacterTable`): Complex character table
            error('Abstract');
        end

    end

    methods % Group properties

        function a = abelianInvariants(self)
        % Returns the group abelian invariants
        %
        % It computes the decomposition of the factor group of this group by its derived subgroup
        % (which is abelian), and returns the primary decomposition of that abelian group.
        %
        % The abelian invariants are sorted in weakly increasing order.
        %
        % Example:
        %   >>> G = replab.PermutationGroup.cyclic(100);
        %   >>> isequal(G.abelianInvariants, [4 25])
        %       1
        %
        % Returns:
        %   integer(1,\*): Group abelian invariants
            error('Abstract');
        end

        function e = exponent(self)
        % Returns the group exponent
        %
        % The group exponent is the smallest integer ``e`` such that ``g^e == identity`` for all ``g`` in ``G``.
        %
        % Returns:
        %   vpi: The group exponent
            error('Abstract');
        end

        function R = fastRecognize(self)
        % Attempts to recognize this group in the standard atlas
        %
        % Returns:
        %   `.FiniteIsomorphism` or ``[]``: A result in case the group is identified; or ``[]`` if unrecognized.
            error('Abstract');
        end

        function res = isCommutative(self)
        % Returns whether this group is commutative
            for i = 1:self.nGenerators
                gi = self.generator(i);
                for j = 1:i-1
                    gj = self.generator(j);
                    if ~self.eqv(self.compose(gi, gj), self.compose(gj, gi))
                        res = false;
                        return
                    end
                end
            end
            res = true;
            return
        end

        function res = isCyclic(self)
        % Returns whether this group is a cyclic group
        %
        % Example:
        %   >>> C3 = replab.PermutationGroup.cyclic(3);
        %   >>> C3.isCyclic
        %       1
        %   >>> C3_C3 = C3.directProduct(C3);
        %   >>> C3_C3.isCommutative
        %       1
        %   >>> C3_C3.isCyclic
        %       0
        %
        % Returns:
        %   logical: True if the group is cyclic
            error('Abstract');
        end

        function res = isSimple(self)
        % Returns whether this group is simple
        %
        % Example:
        %   >>> S5 = replab.S(5);
        %   >>> S5.isSimple
        %       0
        %   >>> A5 = S5.derivedSubgroup;
        %   >>> A5.isSimple
        %       1
        %
        % Returns:
        %   logical: True if the group is simple
            error('Abstract');
        end

        function b = isTrivial(self)
        % Tests whether this group is trivial
        %
        % Returns:
        %   logical: True if this group is trivial (i.e. has only one element)
            b = self.nGenerators == 0;
        end

        function res = knownOrder(self)
        % Returns whether the order of this group has already been computed
        %
        % Returns:
        %   logical: True if the order is known
            error('Abstract');
        end

        function o = order(self)
        % Returns the group order
        %
        % Returns:
        %   vpi: The group order
            error('Abstract');
        end

        function s = presentation(self)
        % Returns a presentation of this group as a string
        %
        % Returns:
        %   charstring: Presentation
            r = self.relatorsWord;
            if isempty(r)
                s = '< | >'; % empty presentation
            else
                gens = strjoin(self.generatorNames, ', ');
                rels = strjoin(r, ' = ');
                s = sprintf('< %s | %s = 1 >', gens, rels);
            end
        end

        function R = recognize(self)
        % Attempts to recognize this group in the standard atlas
        %
        % Returns:
        %   `.FiniteIsomorphism` or ``[]``: A result in case the group is identified; or ``[]`` if unrecognized.
            R = self.cached('recognize', @() replab.Atlas.recognize(self));
        end

    end

    methods % Generators-related methods

        function l = factorizeFlat(self, elementOrCoset)
        % Factorizes an element or a coset as a flat sequence in the generators
        %
        % See `.imageFlat` for the convention.
        %
        % If a coset is given, this method tries to pick a coset element with a short factorization.
        %
        % Args:
        %   elementOrCoset (element or coset of this group): Element or coset to factorize
        %
        % Returns:
        %   integer(1,\*): Flat sequence of the word in the generators
            error('Abstract');
        end

        function w = factorizeWord(self, elementOrCoset)
        % Factorizes an element or a coset as a word in the generators
        %
        % If a coset is given, this method tries to pick a coset element with a short factorization.
        %
        % Example:
        %   >>> G = replab.S(3);
        %   >>> G.factorizeWord([2 3 1])
        %       'x1'
        %   >>> H = G.withGeneratorNames({'s', 't'});
        %   >>> H.factorizeWord([2 3 1])
        %       's'
        %
        % Args:
        %   elementOrCoset (element or coset of this group): Element to factorize
        %
        % Returns:
        %   charstring: Word representing the element
            l = self.factorizeFlat(elementOrCoset);
            w = replab.fp.Letters.print(l, self.generatorNames);
        end

        function w = flatToWord(self, letters)
        % Prints a word described by letters into a string
        %
        % Args:
        %   letters (integer(1,\*)): Letters composing the word
        %
        % Returns:
        %   charstring: Word in the generators
            w = replab.fp.Letters.print(letters, self.generatorNames);
        end

        function p = generator(self, i)
        % Returns the i-th group generator
        %
        % Args:
        %   i (integer, charstring): Generator index or name
        %
        % Returns:
        %   element: i-th group generator
            if isa(i, 'char')
                [b, i] = ismember(i, self.generatorNames);
                assert(b, 'Not a valid generator name');
            end
            p = self.generators{i};
        end

        function p = generatorInverse(self, i)
        % Returns the inverse of the i-th group generator
        %
        % Args:
        %   i (integer, charstring): Generator index or name
        %
        % Returns:
        %   element: Inverse of the i-th group generator
            if isa(i, 'char')
                [b, i] = ismember(i, self.generatorNames);
                assert(b, 'Not a valid generator name');
            end
            p = self.inverse(self.generators{i});
        end

        function names = generatorNames(self)
        % Returns the names of the group generators
        %
        % Returns:
        %   cell(1,\*) of charstring: Generator names
            error('Abstract');
        end

        function res = knownRelators(self)
        % Returns whether the relators of this group are known
        %
        % Returns:
        %   logical: True if the relators are known already
            error('Abstract');
        end

        function g = imageFlat(self, letters)
        % Returns the image of a flat word in the group generators
        %
        % The letters take the values ``1...nG`` which represent the group generators, and also the values
        % ``-nG...-1`` which represent the inverses of those generators.
        %
        % Args:
        %   letters (integer(1,\*)): Letters composing the word.
        %
        % Returns;
        %   element: Element of the group corresponding to the given word
            g = self.composeFlat(self.generators, letters);
        end

        function g = imageWord(self, word)
        % Computes the image of a word in the group generators
        %
        % Example:
        %   >>> G = replab.S(3);
        %   >>> G.imageWord('x1')
        %       2 3 1
        %
        % Args:
        %   word (charstring): Word written using mathematical notation
        %
        % Returns:
        %   element: Element of the group corresponding to the given word
            l = replab.fp.Letters.parse(word, self.generatorNames);
            g = self.imageFlat(l);
        end

        function n = nGenerators(self)
        % Returns the number of group generators
        %
        % Returns:
        %   integer: Number of group generators
            n = length(self.generators);
        end


        function R = relatorsFlat(self)
        % Returns the relators of a presentation of this finite group in the flat format
        %
        % See `.AbstractGroup` for a description of the presentation of a finite group
        %
        % Returns:
        %   cell(1,\*) of integer(1,\*): Relators in flat form
            error('Abstract');
        end

        function R = relatorsWord(self)
        % Returns the relators of a presentation of this finite group
        %
        % Returns:
        %   cell(1,\*) of charstring: Relators in word form
            R = cellfun(@(r) self.flatToWord(r), self.relatorsFlat, 'uniform', 0);
        end

        function l = wordToFlat(self, word)
        % Parses a word into generator letters
        %
        % Args:
        %   word (charstring): Word written using mathematical notation
        %
        % Returns:
        %   integer(1,\*): Letters of the word
            l = replab.fp.Letters.parse(word, self.generatorNames);
        end

    end

    methods % Elements

        function o = elementOrder(self, g)
        % Returns the order of a group element
        %
        % Args:
        %   g (element of this group): Group element
        %
        % Returns:
        %   vpi: The order of ``g``, i.e. the smallest ``o`` such that ``g^o == identity``
            error('Abstract');
        end

        function gens = smallGeneratingSet(self)
        % Returns a small set of elements generating the group
        %
        % Returns:
        %   cell(1,\*) of group elements: Generating set
            gens = self.generators;
            i = 1;
            while i <= length(gens)
                test = horzcat(gens(1:i-1), gens(i+1:end));
                G = self.subgroupWithGenerators(test);
                if G.order == self.order
                    gens = test;
                    % this throws the i-th element, so i is the new i+1
                else
                    i = i + 1;
                end
            end
        end

    end

    methods % Construction of groups

        function res = closure(self, varargin)
        % Computes the group generated by the elements of this group and other elements/groups
        %
        % Arguments can be either elements of `.type` or `.FiniteGroup` of the same type.
        %
        % Example:
        %    >>> G = replab.PermutationGroup.cyclic(3);
        %    >>> S3 = replab.S(3);
        %    >>> H = S3.subgroup({[2 1 3]});
        %    >>> C = G.closure(H);
        %    >>> C == S3
        %        1
        %
        % Returns:
        %   `.FiniteGroup`: The closure
            error('Abstract');
        end

        function conj = leftConjugateGroup(self, by)
        % Returns the left conjugate of the current group by the given element
        %
        % ``res = self.leftConjugateGroup(by)``
        %
        % In particular, it ensures that
        % ``res.generator(i) = self.type.leftConjugate(by, self.generator(i))``
        %
        % Args:
        %   by (element of `.type`): Element to conjugate the group with
        %
        % Returns:
        %   `+replab.FiniteGroup`: The conjugated group
            newGenerators = cellfun(@(g) self.type.leftConjugate(by, g), self.generators, 'uniform', 0);
            conj = self.type.groupWithGenerators(newGenerators, 'order', self.order);
        end

        function res = normalClosure(self, obj)
        % Computes the normal closure of an object in the closure of this group and this object
        %
        % Example:
        %   >>> S5 = replab.S(5);
        %   >>> S4 = S5.subgroup({[2 3 4 1 5] [2 1 3 4 5]});
        %   >>> nc = S4.normalClosure([1 2 4 5 3]); % demonstrates both syntaxes
        %   >>> nc = S4.normalClosure(S5.subgroup({[1 2 4 5 3]}));
        %   >>> nc == S5.subgroup({[1 2 4 5 3] [5 2 3 1 4] [2 5 3 4 1]})
        %       1
        %
        % Example:
        %   >>> S4 = replab.S(4);
        %   >>> nc = S4.normalClosure(S4.subgroup({[2 3 1 4]}));
        %   >>> nc == S4.subgroup({[2 3 1 4] [1 3 4 2]})
        %       1
        %
        % Args:
        %   obj (`.FiniteGroup` or element of `.type`): Group or element to compute the normal closure of
        %
        % Returns:
        %   `+replab.FiniteGroup`: The normal closure of ``obj`` in this group
            error('Abstract');
        end

        function res = withGeneratorNames(self, newNames)
        % Returns a modified copy of this finite group with renamed generators
        %
        % Args:
        %   newNames (cell(1,\*) of charstring): New generator names
        %
        % Returns:
        %   `.FiniteGroup`: Updated copy
            if self.inCache('order')
                res = self.type.groupWithGenerators(self.generators, 'order', self.order, 'generatorNames', newNames);
            else
                res = self.type.groupWithGenerators(self.generators, 'generatorNames', newNames);
            end
        end

    end

    methods % Subgroups

        function sub = center(self)
        % Returns the center of this group
        %
        % Returns:
        %   `.FiniteGroup`: The center
            sub = self.centralizer(self);
        end

        function sub = centralizer(self, arg)
        % Returns the centralizer of the given object in this group
        %
        % Example:
        %   >>> G = replab.S(4);
        %   >>> C = G.centralizer([2 3 1 4]);
        %   >>> C == replab.PermutationGroup.of([2 3 1 4])
        %     1
        %
        % Example:
        %   >>> G = replab.S(4);
        %   >>> C = G.centralizer(G.subgroup({[2 3 1 4]}));
        %   >>> C == replab.PermutationGroup.of([2 3 1 4])
        %     1
        %
        % Args:
        %   rhs (`.FiniteGroup` or group element): Element to compute the centralizer of
        %
        % Returns:
        %   `.FiniteGroup`: The centralizer
            error('Abstract');
        end

        function ser = derivedSeries(self)
        % Returns the derived series of this group
        %
        % Returns:
        %   cell(1,\*) of `.FiniteGroup`:
            D = self.derivedSubgroup;
            if self == D
                ser = {self};
            else
                ser = horzcat({self}, D.derivedSeries);
            end
        end

        function sub = derivedSubgroup(self)
        % Computes the derived subgroup of this group
        %
        % Example:
        %   >>> S4 = replab.S(4);
        %   >>> S4.order
        %       24
        %   >>> D = S4.derivedSubgroup;
        %   >>> D == replab.PermutationGroup.alternating(4)
        %       1
        % Returns:
        %   `+replab.FiniteGroup`: The derived subgroup
            error('Abstract');
        end

        function sub = intersection(self, G)
        % Computes the intersection of two groups
        %
        % Example:
        %   >>> D12 = replab.PermutationGroup.of([1 6 5 4 3 2], [2 1 6 5 4 3]);
        %   >>> G = replab.PermutationGroup.of([2 1 3 4 5 6], [2 3 4 5 1 6]);
        %   >>> I = D12.intersection(G);
        %   >>> I == replab.PermutationGroup.of([5 4 3 2 1 6])
        %       1
        %
        % Args:
        %   G (`+replab.FiniteGroup`): Group with the same type as this group
        %
        % Returns:
        %   `+replab.FiniteGroup`: Subgroup representing the intersection
            error('Abstract');
        end

        function sub = randomProperSubgroup(self, nSteps)
        % Constructs a random proper subgroup of this group
        %
        % The call fails if no proper subgroup exists.
        %
        % Args:
        %   nSteps (integer, optional): How many steps of reduction to perform, default 1
        %
        % Returns:
        %   `.FiniteGroup`: A proper subgroup
            if nargin < 2 || isempty(nSteps)
                nSteps = 1;
            end
            sub = self;
            for i = 1:nSteps
                if isprime(sub.order)
                    if i == 1
                        error('This cyclic group of prime order has no proper subgroup');
                    else
                        return
                    end
                end
                candidate = sub;
                while candidate.order == sub.order
                    s1 = sub.sample;
                    while sub.isIdentity(s1)
                        s1 = sub.sample;
                    end
                    s2 = sub.sample;
                    while sub.isIdentity(s2)
                        s2 = sub.sample;
                    end
                    candidate = sub.subgroup({s1 s2});
                end
                sub = candidate;
            end
        end

        function G = randomSubgroup(self)
        % Constructs a random subgroup of this group
        %
        % Compared to `.randomProperSubgroup`, this method can return the trivial group or ``self``.
        % This method never fails.
        %
        % Returns:
        %   `.FiniteGroup`: A subgroup
            try
                G = self.randomProperSubgroup;
            catch
                if randi(2) == 1
                    G = self;
                else
                    G = self.trivialSubgroup;
                end
            end
        end

        function sub = subgroup(self, elements, varargin)
        % Constructs a subgroup of the current group from elements
        %
        % The generators of the result are the given elements with the identity filtered out.
        %
        % Example:
        %   >>> S5 = replab.S(5);
        %   >>> G = S5.subgroup({[1 2 3 4 5]});
        %   >>> isempty(G.generators)
        %       1
        %
        % Args:
        %   elements (cell(1,\*) of elements of this group): List of elements
        %
        % Keyword Args:
        %   generatorNames (cell(1,\*) of charstring, optional): Names of the generators
        %   order (vpi or integer, optional): Group order
        %   relators (cell(1,\*) of charstring or integer(1,\*), optional): Relators
        %
        % Returns:
        %   `+replab.FiniteGroup`: The subgroup generated by `.generators`
            mask = cellfun(@(e) self.isIdentity(e), elements);
            sub = self.subgroupWithGenerators(elements(~mask), varargin{:});
        end

        function sub = subgroupWithGenerators(self, generators, varargin)
        % Constructs a subgroup of the current group from generators
        %
        % Guarantees that the constructed subgroup preserves the order of the generators. However, the
        % given generators cannot contain the identity element.
        %
        % Example:
        %   >>> S5 = replab.S(5);
        %   >>> G = S5.subgroupWithGenerators({[2 3 4 5 1]});
        %   >>> isequal(G.generators{1}, [2 3 4 5 1])
        %       1
        %
        % Args:
        %   generators (cell(1,\*) of elements of this group): List of generators, does not contain the identity
        %
        % Keyword Args:
        %   generatorNames (cell(1,\*) of charstring, optional): Names of the generators
        %   order (vpi or integer, optional): Group order
        %   relators (cell(1,\*) of charstring or integer(1,\*), optional): Relators
        %
        % Returns:
        %   `+replab.FiniteGroup`: The subgroup generated by `.generators`
            sub = self.type.subgroupWithGenerators(self, generators, varargin{:});
        end

        function sub = trivialSubgroup(self)
        % Returns the trivial subgroup of this group
        %
        % Returns:
        %   `+replab.FiniteGroup`: The trivial subgroup
            sub = self.subgroupWithGenerators({}, 'order', vpi(1));
        end

    end

    methods % Cosets

        function c = doubleCoset(self, element, rightSubgroup, varargin)
        % Returns a double coset
        %
        % Returns the set ``self * element * rightSubgroup``.
        %
        % Args:
        %   element (group element): Group element
        %   rightSubgroup (`.FiniteGroup`): Finite group
        %
        % Keyword Args:
        %   group (`.FiniteGroup`, optional): Group containing both ``self`` and ``element``, computed if omitted
        %   isCanonical (logical, optional): Whether the given ``element`` is canonical w.r.t. to the group ordering
        %
        % Returns:
        %   `+replab.DoubleCoset`: The constructed double coset
            error('Abstract');
        end

        function c = doubleCosets(self, leftSubgroup, rightSubgroup)
        % Returns the set of double cosets in this group by the given groups
        %
        %
        % Example:
        %   >>> n = 5;
        %   >>> G = replab.S(n);
        %   >>> H = G.pointwiseStabilizer(n);
        %   >>> cosets = G.doubleCosets(H, H);
        %   >>> cosets.nElements
        %       2
        %
        % Example:
        %   >>> G = replab.S(3);
        %   >>> H = replab.PermutationGroup.of([2 1 3]);
        %   >>> K = replab.PermutationGroup.of([3 2 1]);
        %   >>> cosets = G.doubleCosets;
        %   >>> cosets.nElements
        %       2
        %
        % Args:
        %   leftSubgroup (`+replab.FiniteGroup`): First subgroup
        %   rightSubgroup (`+replab.FiniteGroup`): Second subgroup
        %
        % Returns:
        %   `+replab.DoubleCosets`: The set of double cosets
            error('Abstract');
        end

        function l = isNormalizedBy(self, element)
        % Returns whether a given element/group normalizes this group
        %
        % This is true when ``element * group * == group * element``.
        %
        % The same definition when ``element`` is a group; then we ask that all this group elements satisfy that property.
        %
        % Args:
        %   element (group element or `.FiniteGroup`): Group element or group
        %
        % Returns:
        %   logical: True if the given element/group normalizes this group
            if isa(element, 'replab.FiniteGroup')
                l = all(cellfun(@(g) self.isNormalizedBy(g), element.generators));
            else
                l = false;
                for i = 1:self.nGenerators
                    g = self.generator(i);
                    if ~self.contains(self.type.leftConjugate(element, g))
                        return
                    end
                end
                l = true;
            end
        end

        function c = leftCoset(self, element, varargin)
        % Returns a left coset
        %
        % Returns the set ``element * self``.
        %
        % Args:
        %   element (group element): Group element
        %
        % Keyword Args:
        %   group (`.FiniteGroup`, optional): Group containing both ``self`` and ``element``, computed if omitted
        %   isCanonical (logical, optional): Whether the given ``element`` is canonical w.r.t. to the group ordering
        %
        % Returns:
        %   `+replab.LeftCoset`: The constructed right coset
            error('Abstract');
        end

        function c = leftCosets(self, subgroup)
        % Returns the set of left cosets of the given subgroup in this group
        %
        % Args:
        %   subgroup (`+replab.FiniteGroup`): Subgroup of this group
        %
        % Returns:
        %   `+replab.LeftCosets`: Left cosets
            error('Abstract');
        end

        function c = mldivide(self, supergroup)
        % Shorthand for `.rightCosets`
            c = supergroup.rightCosets(self);
        end

        function c = mrdivide(self, subgroup)
        % Shorthand for `.leftCosets`
            c = self.leftCosets(subgroup);
        end

        function c = normalCoset(self, element, varargin)
        % Returns a normal coset
        %
        % Returns the set ``element * self == self * element``.
        %
        % Args:
        %   element (group element): Group element
        %
        % Keyword Args:
        %   group (`.FiniteGroup`, optional): Group containing both ``self`` and ``element``, computed if omitted
        %   isCanonical (logical, optional): Whether the given ``element`` is canonical w.r.t. to the group ordering
        %
        % Returns:
        %   `+replab.NormalCoset`: The constructed normal coset
            error('Abstract');
        end

        function c = normalCosets(self, subgroup)
        % Returns the set of normal cosets of the given subgroup in this group
        %
        % Args:
        %   subgroup (`+replab.FiniteGroup`): Normal subgroup of this group
        %
        % Returns:
        %   `.NormalCosets`: The set of normal cosets
            error('Abstract');
        end

        function c = rightCoset(self, element, varargin)
        % Returns a right coset
        %
        % Returns the set ``self * element``.
        %
        % Args:
        %   element (group element): Group element
        %
        % Keyword Args:
        %   group (`.FiniteGroup`, optional): Group containing both ``self`` and ``element``, computed if omitted
        %   isCanonical (logical, optional): Whether the given ``element`` is canonical w.r.t. to the group ordering
        %
        % Returns:
        %   `+replab.RightCoset`: The constructed right coset
            error('Abstract');
        end

        function c = rightCosets(self, subgroup)
        % Returns the set of right cosets of the given subgroup in this group
        %
        % Args:
        %   subgroup (`+replab.FiniteGroup`): Subgroup of this group
        %
        % Returns:
        %   `+replab.RightCosets`: Right cosets
            error('Abstract');
        end

    end

    methods % Relations to other groups

        function res = isNormalSubgroupOf(self, rhs)
        % Returns whether this group is a normal subgroup of another group
        %
        % Example:
        %   >>> S3 = replab.S(3);
        %   >>> A3 = replab.PermutationGroup.alternating(3);
        %   >>> A3.isNormalSubgroupOf(S3)
        %       1
        %
        % Example:
        %   >>> S3 = replab.S(3);
        %   >>> G = S3.subgroup({[2 1 3]});
        %   >>> G.isNormalSubgroupOf(S3)
        %       0
        %
        % Args:
        %   rhs (`+replab.FiniteGroup`): Other group with the same type as this one
        %
        % Returns:
        %   logical: True if this group is a normal subgroup of ``rhs``
            if ~self.isSubgroupOf(rhs)
                res = false;
                return
            end
            for i = 1:self.nGenerators
                subi = self.generator(i);
                for j = 1:rhs.nGenerators
                    rhsj = rhs.generator(j);
                    if ~self.contains(self.type.leftConjugate(rhsj, subi))
                        res = false;
                        return
                    end
                end
            end
            res = true;
        end

        function res = isSubgroupOf(self, rhs)
        % Returns whether this group is a subgroup of another group
        %
        % Example:
        %   >>> S3 = replab.S(3);
        %   >>> G = S3.subgroup({[2 1 3]});
        %   >>> G.isSubgroupOf(S3)
        %       1
        %
        % Args:
        %   rhs (`+replab.FiniteGroup`): Other group with the same type as this one
        %
        % Returns:
        %   logical: True if this group is a subgroup of ``rhs``
            res = all(cellfun(@(g) rhs.contains(g), self.generators));
        end

    end

    methods % Isomorphic groups

        function G = abstractGroup(self)
        % Returns an abstract group isomorphic to this finite gorup
        %
        % The generators of the abstract group must be in one-to-one correspondance with the generators of this group, and
        % their names are taken from `.generatorNames`
        %
        % This is the image of `.abstractIsomorphism`; and the `+replab.AbstractGroup.permutationGroup` will be the same as this group
        % `.permutationGroup`. TODO: check relevance
        %
        % Returns:
        %   `+replab.AbstractGroup`: An abstract group isomorphic to this group
            G = self.abstractIsomorphism.target;
        end

        function G = permutationGroup(self)
        % Returns the permutation group isomorphic to this finite group
        %
        % The generators of the permutation group are in one-to-one correspondance with the generators of this group.
        %
        % This is the image of `.permutationIsomorphism`.
        %
        % Returns:
        %   `+replab.PermutationGroup`: A permutation group isomorphic to this group
            G = self.permutationIsomorphism.target;
        end

    end

    methods % Morphisms

        function m = abstractIsomorphism(self)
        % Returns an isomorphism to an abstract group
        %
        % Example:
        %   >>> G = replab.S(3);
        %   >>> f = G.abstractIsomorphism;
        %   >>> f.imageElement([2 3 1])
        %       'x1'
        %
        % Returns:
        %   `.FiniteIsomorphism`: Isomorphism to an abstract group
            m = self.cached('abstractIsomorphism', @() replab.abstract.Isomorphism(self));
        end

        function m = conjugatingAutomorphism(self, by)
        % Returns the morphism that corresponds to left conjugation by an element
        %
        % Args:
        %   by (element of `.type`): Element to conjugate the group with
        %
        % Returns:
        %   `+replab.FiniteMorphism`: Conjugating automorphism
            generatorImages = cellfun(@(g) self.type.leftConjugate(by, g), self.generators, 'uniform', 0);
            assert(all(cellfun(@(g) self.contains(g), generatorImages)));
            m = self.morphismByImages(self, 'preimages', self.generators, 'images', generatorImages, 'nChecks', 0);
        end

        function res = findIsomorphism(self, to)
        % Finds an isomorphism from this finite group to another finite group, if it exists
        %
        % Args:
        %   to (`+replab.FiniteGroup`): Target of the isomorphism
        %
        % Returns:
        %   `.FiniteIsomorphism` or ``[]``: The isomorphism if it exists, or an empty array
            res = self.findIsomorphisms(to, 'single', true, 'upToConjugation', true);
            if ~isempty(res)
                res = res{1};
            else
                res = [];
            end
        end

        function res = findIsomorphisms(self, to, varargin)
        % Finds all the isomorphisms from this finite group to another finite group
        %
        % Example:
        %   >>> G = replab.S(6);
        %   >>> m = G.findIsomorphisms(G, 'upToConjugation', true);
        %   >>> length(m)
        %       2
        %
        % Args:
        %   to (`+replab.FiniteGroup`): Target of the isomorphism
        %
        % Keyword Args:
        %   upToConjugation (logical, optional): Whether to list morphisms up to conjugation of the image group, default: false
        %   single (logical, optional): Whether to return maximum a single result, default: false
        %
        % Returns:
        %   cell(1,\*) of `.FiniteIsomorphism`: The isomorphisms
            args = struct('upToConjugation', false, 'single', false);
            args = replab.util.populateStruct(args, varargin);
            if args.single
                args.upToConjugation = true;
            end
            if self.isTrivial
                if to.isTrivial
                    res = {self.isomorphismByImages(to, 'preimages', {}, 'images', {})};
                else
                    res = [];
                end
                return
            end
            F = self;
            G = to;
            A = to;
            if F.order ~= G.order
                res = cell(1, 0);
                return
            end
            fm = replab.mrp.FindMorphisms(F, G, A, 'isomorphisms', args.single);
            if args.upToConjugation || args.single
                res = fm.searchUpToConjugation;
            else
                res = fm.searchAll;
            end
            res = cellfun(@(m) m.toIsomorphism, res, 'uniform', 0);
        end

        function res = findMorphisms(self, to, varargin)
        % Finds all the morphisms from this finite group to another finite group
        %
        % Example:
        %   >>> S3 = replab.S(3);
        %   >>> S4 = replab.S(4);
        %   >>> m = S4.findMorphisms(S3, 'upToConjugation', true, 'surjective', false);
        %   >>> length(m)
        %       3
        %
        % Args:
        %   to (`+replab.FiniteGroup`): Target of the morphism
        %
        % Keyword Args:
        %   upToConjugation (logical, optional): Whether to list morphisms up to conjugation of the image group, default: false
        %   surjective (logical, optional): Whether to consider only surjective morphisms (or epimorphisms), whose image span ``to``, default: false
        %   single (logical, optional): Whether to return maximum a single result, default: false
        %
        % Returns:
        %   cell(1,\*) of `.FiniteMorphism`: The morphisms
            args = struct('upToConjugation', false, 'surjective', false, 'single', false);
            args = replab.util.populateStruct(args, varargin);
            if args.single
                args.upToConjugation = true;
            end
            if args.surjective
                if self.order == to.order
                    res = self.findIsomorphisms(to, 'upToConjugation', args.upToConjugation, 'single', args.single);
                    return
                else
                    filter = 'epimorphisms';
                end
            else
                filter = 'morphisms';
            end
            if self.isTrivial
                res = {self.morphismByImages(to, 'preimages', {}, 'images', {})};
                return
            end
            F = self;
            G = to;
            A = to;
            fm = replab.mrp.FindMorphisms(F, G, A, filter, args.single);
            if args.upToConjugation || args.single
                res = fm.searchUpToConjugation;
            else
                res = fm.searchAll;
            end
        end

        function l = isMorphismByImages(self, target, varargin)
        % Checks whether the given images describe a group morphism
        %
        % The calling convention of this method is the same as `.morphismByImages`, except that ``nChecks`` is missing.
        %
        % Args:
        %   target (`+replab.Group`): Target group
        %
        % Keyword Args:
        %   preimages (cell(1, \*) of ``self`` elements): Preimages of the morphism which generate ``self``, defaults to ``self.generators``
        %   images (cell(1, \*) of ``target`` elements): Images of the given preimages, defaults to ``target.generators`` if ``target`` is a `.FiniteGroup`
        %
        % Returns:
        %   logical: True if the given images define a morphism
            assert(isa(target, 'replab.Group'));
            args = struct('preimages', {self.generators});
            if isa(target, 'replab.FiniteGroup')
                args.images = target.generators;
            else
                args.images = [];
            end
            args = replab.util.populateStruct(args, varargin);
            if isempty(args.images) && ~self.isTrivial
                error('Images must be provided');
            end
            assert(length(args.preimages) == length(args.images), 'Number of images does not match the number of preimages');
            preId = cellfun(@(g) self.isIdentity(g), args.preimages);
            l = cellfun(@(g) target.isIdentity(g), args.images(preId));
            if ~all(l)
                return
            end
            l = self.isMorphismByImages_(target, args.preimages(~preId), args.images(~preId));
        end

        function m = isomorphismByFunction(self, target, imageElementFun, varargin)
        % Constructs an isomorphism to a finite group using an image function
        %
        % Due to the additional structure on ``target``, this method returns a `.FiniteIsomorphism`,
        % and does not need an explicit preimage function.
        %
        % Args:
        %   target (`.FiniteGroup` or `.FiniteGroupType`): Finite group isomorphic to the present group
        %   imageElementFun (function_handle): Function that computes the image of a source element
        %
        % Keyword Args:
        %   preimageElementFun (function_handle, optional): Function the computes the preimage of a target element
        %
        % Returns:
        %   `.FiniteIsomorphism`: The constructed isomorphism
            imgs = cellfun(imageElementFun, self.generators, 'uniform', 0);
            m = self.isomorphismByImages(target, 'preimages', self.generators, 'images', imgs);
        end

        function m = isomorphismByImages(self, target, varargin)
        % Constructs an isomorphism to a group using images of generators
        %
        % Args:
        %   target (`.FiniteGroup` or `.FiniteGroupType`): Target of the isomorphism
        %
        % Keyword Args:
        %   preimages (cell(1, \*) of ``self`` elements): Preimages of the isomorphism which generate ``self``, defaults to ``self.generators``
        %   images (cell(1, \*) of ``target`` elements): Images of the given preimages, defaults to ``target.generators``
        %   imageElementFun (function_handle or ``[]``, optional): Image function, default: ``[]``
        %   nChecks (integer or ``inf``): Number of randomized image checks to perform, if ``inf`` computes and verifies a presentation of ``self``
            assert(isa(target, 'replab.FiniteGroup'));
            m = self.morphismByImages(target, varargin{:}).toIsomorphism;
        end

        function m = morphismByImages(self, target, varargin)
        % Constructs a morphism to a group using images of generators
        %
        % The type of the morphism depends on the type of ``target``:
        %
        % * if ``target`` is a `.FiniteGroup` or a `.FiniteGroupType`, this method returns a `.FiniteMorphism`,
        %
        % * if ``target`` is only a `.Group`, this method returns a `.Morphism`.
        %
        % Example:
        %   >>> S4 = replab.S(4);
        %   >>> m = S4.morphismByImages(replab.S(3), 'images', {[1 3 2] [3 2 1]});
        %   >>> m.laws.checkSilent
        %       1
        %
        % Args:
        %   target (`.Group` or `.FiniteGroup`): Target of the morphism, the morphism image is a subgroup of this
        %
        % Keyword Args:
        %   preimages (cell(1, \*) of ``self`` elements): Preimages of the morphism which generate ``self``, defaults to ``self.generators``
        %   images (cell(1, \*) of ``target`` elements): Images of the given preimages, defaults to ``target.generators`` if ``target`` is a `.FiniteGroup`
        %   imageElementFun (function_handle or ``[]``, optional): Image function, default: ``[]``
        %   nChecks (integer or ``inf``): Number of randomized image checks to perform, if ``inf`` computes and verifies a presentation of ``self``
        %
        % Returns:
        %   `.Morphism` or `.FiniteMorphism`: The constructed morphism
            args = struct('nChecks', replab.globals.morphismNChecks, 'preimages', {self.generators}, 'imageElementFun', []);
            if length(varargin) == 1 && iscell(varargin{1})
                warning('Old call style deprecated, add a ''images'' keyword argument');
                args.images = varargin{1};
            else
                if isa(target, 'replab.FiniteGroup')
                    args.images = target.generators;
                else
                    args.images = [];
                end
                args = replab.util.populateStruct(args, varargin);
            end
            if isempty(args.images) && ~self.isTrivial
                error('Images must be provided');
            end
            if isa(target, 'replab.gen.StaticFiniteGroupType')
                target = target.parentGroup;
            elseif isa(target, 'replab.FiniteGroupType')
                isId = cellfun(@(g) target.isIdentity(g), args.images, 'uniform', 0);
                target = target.groupWithGenerators(args.images(~isId));
            end
            assert(length(args.preimages) == length(args.images), 'Number of images does not match the number of preimages');
            preId = cellfun(@(g) self.isIdentity(g), args.preimages);
            assert(all(cellfun(@(g) target.isIdentity(g), args.images(preId))), 'Images of identity must be identity');
            if isinf(args.nChecks)
                assert(self.isMorphismByImages_(target, args.preimages, args.images), 'The given images do not define a morphism');
            end
            m = self.morphismByImages_(target, args.preimages(~preId), args.images(~preId), args.imageElementFun);
            if isfinite(args.nChecks) && args.nChecks > 0
                for i = 1:args.nChecks
                    s1 = self.sample;
                    s2 = self.sample;
                    s12 = self.compose(s1, s2);
                    t1 = m.imageElement(s1);
                    t2 = m.imageElement(s2);
                    t12 = m.imageElement(s12);
                    t1_2 = target.compose(t1, t2);
                    assert(target.eqv(t12, t1_2), 'The given images do not define a morphism');
                end
            end
        end

        function f = permutationIsomorphism(self)
        % Returns the isomorphism from this group to a permutation group
            error('Abstract');
        end

    end

    methods (Access = protected)

        % Morphisms

        function m = morphismByImages_(self, target, preimages, images, imageElementFun)
        % Implements the `.morphismByImages` method
        %
        % Does not perform checks; preimages must not contain the identity
            error('Abstract');
        end

        function l = isMorphismByImages_(self, target, preimages, images)
        % Implements the `.isMorphismByImages` method
        %
        % Preimages must not contain the identity (this is not checked)
            hasSameGenerators = length(preimages) == self.nGenerators && ...
                all(arrayfun(@(i) self.eqv(preimages{i}, self.generator(i)), 1:self.nGenerators));
            if hasSameGenerators
                source = self;
            else
                source = self.subgroupWithGenerators(preimages);
            end
            assert(source == self, 'The morphism preimages do not generate the source group');
            relators = source.relatorsFlat;
            for i = 1:length(relators)
                g = target.composeFlat(images, relators{i});
                if ~target.isIdentity(g)
                    l = false;
                    return
                end
            end
            l = true;
        end

    end

    methods % Representations

        function rep = regularRep(self)
        % Returns the left regular representation of this group
        %
        % Returns:
        %   `.Rep`: The left regular representation as a real permutation representation
            error('Abstract');
        end

        function rho = repByImages(self, field, dimension, varargin)
        % Constructs a finite dimensional representation of this group from preimages/images pairs
        %
        % The preimages need to generate this group. If the preimages are omitted, they default to
        % the generators of this group.
        %
        % The images can either be exact, in which case they should be provided as `.cyclotomic` matrices,
        % or as ``double`` matrices -- the latter only if they have integer entries.
        % In the case of exact images, the keyword argument ``imagesErrorBound`` can be omitted.
        % When images are exact, RepLAB has the freedom of performing matrix products containing an
        % arbitrary number of factors without loss of precision, and thus a wider range of algorithm
        % can be used. Also, the constructed representation can return exact images using ``rep.image(g, 'exact')``
        %
        % Otherwise, the provided images will be considered inexact. In that case, RepLAB uses a factorization
        % algorithm to decompose group elements as short words in the preimages. The keyword argument
        % ``imagesErrorBound`` should be given as well; it corresponds to an upper bound on the error of the
        % matrix images in the Frobenius norm.
        % Either a single number can be provided, as an upper bound on all images in the provided set; or an individual
        % bound for each image. However, this error bound will be ignored for each image provided as an interval matrix.
        % If inexact floating-point images are provided but ``imagesErrorBound`` is omitted, an ad-hoc error is
        % estimated and a warning is emitted.
        %
        % If the images are exact, the ``isUnitary`` keyword parameter can be omitted.
        %
        % Example:
        %   >>> S4 = replab.S(4);
        %   >>> m = S4.repByImages('R', 1, 'images', {-1 -1});
        %   >>> m.laws.checkSilent
        %       1
        %
        % Args:
        %   field ({'R', 'C'}): Whether the representation is real (R) or complex (C)
        %   dimension (integer): Representation dimension
        %
        % Keyword Args:
        %   preimages (cell(1,n) of ``self`` elements, optional): Preimages of the representation map which generate ``self``, defaults to ``self.generators``
        %   images (cell(1,n) of double(d,d) or cyclotomic(d,d), may be sparse): Images of the given preimages
        %   imagesErrorBound (double or double(1,d) or ``[]``): Error
        %   isUnitary (logical or ``[]``, optional): Value of the constructed `.Rep.isUnitary`; a "true" value accelerates computations
        %   isIrreducible (logical or ``[]``, optional): Value of the constructed `.Rep.isIrreducible`
        %   trivialDimension (integer or ``[]``, optional): Value of the constructed `.Rep.trivialDimension`
        %   frobeniusSchurIndicator (integer or ``[]``, optional): Value of the constructed `.Rep.frobeniusSchurIndicator`
        %   divisionAlgebraName % ('R->C', 'C->R', 'H->C', 'H->R:rep', '', optional): Name of the division algebra encoding this representation respects, default ``''``
        %
        % Returns:
        %   `+replab.RepByImages`: The constructed group representation
            args = struct('preimages', {self.generators}, 'images', {{}});
            if length(varargin) == 1 && iscell(varargin{1})
                warning('Deprecated call convention');
                rho = replab.rep.repByImages(self, field, dimension, 'images', varargin{1});
            else
                rho = replab.rep.repByImages(self, field, dimension, varargin{:});
            end
        end

        function rho = permutationRep(self, dimension, varargin)
        % Constructs a permutation representation of this group
        %
        % The returned representation is real. Use `+replab.Rep.complexification` to obtain a complex representation.
        %
        % Example:
        %   >>> C3 = replab.PermutationGroup.cyclic(3);
        %   >>> rep = C3.permutationRep(3, 'preimages', {[2 3 1]}, 'images', {[3 1 2]});
        %   >>> rep.dimension
        %       3
        %
        % Args:
        %   dimension (integer): Dimension of the representation
        %
        % Keyword Args:
        %   preimages (cell(1,n) of ``self`` elements, optional): Preimages of the representation map which generate ``self``, defaults to ``self.generators``
        %   images (cell(1,\*) of permutations): Images of the generators as permutations of size ``dimension``
        %
        % Returns:
        %   `+replab.Rep`: The constructed group representation
            args = struct('preimages', {self.generators}, 'images', {{}});
            args = replab.util.populateStruct(args, varargin);
            preimages = args.preimages;
            images = cellfun(@(g) replab.Permutation.toSparseMatrix(g), args.images, 'uniform', 0);
            assert(length(preimages) == length(images), 'Must provide as many images as preimages');
            imageElements = cellfun(@(g) [g; zeros(1, dimension)], args.images, 'uniform', 0);
            imageGroup = replab.perm.GeneralizedSymmetricGroupType(dimension, 1);
            rho = replab.rep.RepByImages_monomial(self, 'R', dimension, preimages, images, imageGroup, imageElements, ...
                                                  'isIrreducible', dimension == 1);
        end

        function rho = signedPermutationRep(self, dimension, varargin)
        % Returns a real signed permutation representation of this group
        %
        % The returned representation is real. Use ``rep.complexification`` to obtain a complex representation.
        %
        %   >>> S2 = replab.S(2);
        %   >>> rep = S2.signedPermutationRep(1, 'preimages', {[2 1]}, 'images', {[-1]});
        %   >>> rep.image([2 1])
        %       -1
        %
        % Args:
        %   dimension: Dimension of the representation
        %
        % Keyword Args:
        %   preimages (cell(1,n) of ``self`` elements, optional): Preimages of the representation map which generate ``self``, defaults to ``self.generators``
        %   images (cell(1,\*) of signed permutations): Images of the generators as signed permutations of size ``dimension``
        %
        % Returns:
        %   `+replab.Rep`: The constructed group representation
            args = struct('preimages', {self.generators}, 'images', {{}});
            args = replab.util.populateStruct(args, varargin);
            preimages = args.preimages;
            images = cellfun(@(g) replab.SignedPermutation.toSparseMatrix(g), args.images, 'uniform', 0);
            assert(length(preimages) == length(images), 'Must provide as many images as preimages');
            imageElements = cellfun(@(g) [abs(g); (1-sign(g))/2], args.images, 'uniform', 0);
            imageGroup = replab.perm.GeneralizedSymmetricGroupType(dimension, 2);
            rho = replab.rep.RepByImages_monomial(self, 'R', dimension, preimages, images, imageGroup, imageElements);
        end

    end

end
