function elements = SimpleDimino(generators, group)
% Returns all elements of the group generated by the given generators
% 
% Dimino's algorithm:
% Butler, Gregory. “List of Elements.” FUNDAMENTAL ALGORITHMS FOR PERMUTATION GROUPS, 
% by Gregory Butler, Springer-Verlag, 1991, pp. 14–23.
% 
% Args:
%   generators (cell array): generating elements of the group
%   group (replab Group object): group used for composition, equivalence,
%                                   and identity
%
% Returns 
%   elements (cell array): all group elements 
%
% Example:
% S3 = replab.S(3)
% replab.SimpleDimino({[2,3,1],[2,1,3]}, S3) returns all elements in the 
%                                               S3 permutation group


%%% Check generators are provided
if isempty(length(generators))
    return
end


%%% Check that none of the generators are the identity
i = 1;
while i <= length(generators)
    if group.eqv(generators{i}, group.identity)
        generators(i) = [];
    end
    i = i+1;
end

%%% simple Dimino's algorithm

% add cyclic group of first generator
order = 1;
elements = {group.identity}; 
s1 = generators{1};
g = s1;
% add powers of s1 until getting back to identity
while ~group.eqv(g, group.identity) 
    order = order + 1;
    elements{order} = g;
    g = group.compose(g, s1);
end

% inductive steps in algorithm
for i = 2:length(generators)
    s = generators{i};
    not_redundant = 1; 
    % check generator s is not already in elements
    for e = 1:length(elements)
        if group.eqv(elements{e}, s) 
            not_redundant = 0; 
            break
        end
    end
    if not_redundant
        prev_order = order;
        order = order + 1;
        elements{order} = s;
        % compose previous elements with new generator
        for j = 2:prev_order
            order = order + 1;
            elements{order} = group.compose(elements{j}, s);
        end

        % use coset to add new elements
        cos_pos = prev_order + 1; % first element in coset is generator s
        while cos_pos <= order
            for n = 1:length(generators)
                sn = generators{n};
                % left multiply the elements of the coset
                elmt = group.compose(elements{cos_pos}, sn);
                add_coset = 1;
                for e = 1:length(elements)
                    if group.eqv(elements{e}, elmt)
                        add_coset = 0;
                        break
                    end
                end
                if add_coset % add elmt to coset if not in elements
                    order = order + 1;
                    elements{order} = elmt;
                    % right multiply all previous elements with the new
                    % element in the coset
                    for j = 2:prev_order
                        order = order + 1;
                        elements{order} = group.compose(elements{j}, elmt);
                    end
                end
            end
            % move the coset position to the position of elmt
            cos_pos = cos_pos + prev_order;
        end
        
    end
end

end
