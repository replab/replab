function elements = CompleteDimino(generators, group)
% Returns all elements of the group generated by the given generators
% 
% Dimino's algorithm:
% Butler, Gregory. “List of Elements.” FUNDAMENTAL ALGORITHMS FOR PERMUTATION GROUPS, 
% by Gregory Butler, Springer-Verlag, 1991, pp. 14–23.
% 
% Args:
%   generators (cell array): generating elements of the group
%   group (replab Group object): 
%
% Returns 
%   elements (cell array): all group elements 
%
% Ex. dimino({[2,3,1],[2,1,3]}) returns all
% elements in the S3 permutation group


%%% Check generators are provided
if isempty(generators)
    return
end

t = length(generators);

%%% Check that none of the generators are the identity
i = 1;
while i <= t
    if group.eqv(generators{i}, group.identity)
        generators(i) = [];
    end
    i = i+1;
end

%%% simple Dimino's algorithm

% add cyclic group of first generator
order = 1;
elements = {group.identity}; 
s1 = generators{1};
g = s1;
% add powers of s1 until getting back to identity
while ~group.eqv(g, group.identity) 
    order = order + 1;
    elements{order} = g;
    g = group.compose(g, s1);
end

% inductive steps in algorithm
for i = 2:t
    s = generators{i};
    not_redundant = 1; 
    % check generator s is not already in elements
    for e = 1:length(elements)
        if group.eqv(elements{e}, s) 
            not_redundant = 0; 
            break
        end
    end
    if not_redundant
    % check subgroup of previous elements (H) is normal in <H, s>
        sinv = group.inverse(s);
        normal = 1;
        for j = 1:(i-1) % generators H (current subgroup) are s1 to s(i-1)
            conjugate = group.compose(sinv, group.compose(generators{j}, s));
            for k = 2:length(elements)
                if group.eqv(elements{k}, conjugate)
                    break
                end
            end
            if k == length(elements)
                normal = 0;
                break
            end
        end
        
       % If normal = 1, we don't have to check si*s since s*si in elements
        
        prev_order = order;
        order = order + 1;
        elements{order} = s;
        % compose previous elements with new generator
        for j = 2:prev_order
            order = order + 1;
            elements{order} = group.compose(elements{j}, s);
        end

        % use coset to add new elements
        if normal
            cos_pos = prev_order + 1; % first element in coset is generator s
            while cos_pos <= order
                cos_rep = group.compose(elements{cos_pos}, s);
                add_coset = 1;
                for e = 1:length(elements)
                    if group.eqv(elements{e}, cos_rep)
                        add_coset = 0;
                        break
                    end
                end
                if add_coset
                    order = order + 1;
                    elements{order} = cos_rep;
                    for j = 2:prev_order
                        order = order + 1;
                        elements{order} = group.compose(elements{j}, cos_rep);
                    end
                end
                cos_pos = cos_pos + prev_order;
            end
        else
            cos_pos = prev_order + 1; % first element in coset is generator s
            while cos_pos <= order
                for n = 1:length(generators)
                    sn = generators{n};
                    % left multiply the elements of the coset
                    elmt = group.compose(elements{cos_pos}, sn);
                    add_coset = 1;
                    for e = 1:length(elements)
                        if group.eqv(elements{e}, elmt)
                            add_coset = 0;
                            break
                        end
                    end
                    if add_coset % add elmt to coset if not in elements
                        order = order + 1;
                        elements{order} = elmt;
                        % right multiply all previous elements with the new
                        % element in the coset
                        for j = 2:prev_order
                            order = order + 1;
                            elements{order} = group.compose(elements{j}, elmt);
                        end
                    end
                end
                % move the coset position to the position of elmt
                cos_pos = cos_pos + prev_order;
            end
        end
       
        
    end
end

end
