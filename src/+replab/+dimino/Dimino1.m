function elements = Dimino1(group, generators, getSize, find, insert, at)
% Returns all elements of the group generated by the given generators
%
% Dimino's algorithm:
% Butler, Gregory. “List of Elements.” FUNDAMENTAL ALGORITHMS FOR PERMUTATION GROUPS,
% by Gregory Butler, Springer-Verlag, 1991, pp. 14–23.
%
% Args:
%   generators (cell(1,\*) of group elements): Generating set for the group to construct
%   group (`+replab.Group`): group used for composition, equivalence, and identity
%
% Example:
%   >>> S3 = replab.S(3)
%   >>> %replab.SimpleDimino({[2,3,1],[2,1,3]}, S3) returns all elements in the S3 permutation group

    ind = insert(group.identity); % Add the identity
    assert(ind == 1);
    order = 1;


    if isempty(generators) % If the generating set is empty, return, we're done
        return
    end

    assert(~any(cellfun(@(g) group.isIdentity(g), generators)), 'Generators must not include the identity');

    % Add cyclic group generated by generators{1}
    s1 = generators{1};
    g = s1;
    % add powers of s1 until getting back to identity
    while ~group.isIdentity(g)
        order = order + 1;
        ind = insert(g);
        assert(order == ind);
        g = group.compose(g, s1);
    end

    t = length(generators);
    % inductive steps in algorithm
    for i = 2:length(generators)
        si = generators{i};
        ind = find(si);
        if ind > 0
            previous_order = order; % H_{i-1}
            order = order + 1; % first useful coset representative is si, add a coset
            ind = insert(si);
            assert(order == ind);
            for j = 2:previous_order
                order = order + 1;
                ind = insert(group.compose(at(j), si));
                assert(order == ind);
            end

            % use coset to add new elements
            rep_pos = previous_order + 1; % first element in coset is generator s
            while rep_pos <= order
                for n = 1:length(generators)
                    sn = generators{n};
                    % left multiply the elements of the coset
                    elmt = group.compose(elements{cos_pos}, sn);
                    add_coset = 1;
                    for e = 1:length(elements)
                        if group.eqv(elements{e}, elmt)
                            add_coset = 0;
                            break
                        end
                    end
                    if add_coset % add elmt to coset if not in elements
                        order = order + 1;
                        elements{order} = elmt;
                        % right multiply all previous elements with the new
                        % element in the coset
                        for j = 2:prev_order
                            order = order + 1;
                            elements{order} = group.compose(elements{j}, elmt);
                        end
                    end
                end
                % move the coset position to the position of elmt
                cos_pos = cos_pos + prev_order;
            end

        end
    end

end
